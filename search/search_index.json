{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"gungheap.com This is a blog. \"Gung Heap\" is a quasi- portmanteau of \"Gung Ho\" and \"Dung Heap\". It is inspired by the Programmer Archaeologists of the Qeng Ho, pronounced Chung Ho (ref: \"A Fire Upon the Deep\", Vernor Vinge) and rhyming with \"Gung Ho\". The name is originally from our Noisebridge Gung Heap . I'm reusing it for my blog because I still like the name. Github Pages The github pages are rendered with portray and mkdocs-awesome-pages-plugin Portray is configured in pyproject.toml requiring the project to have a docs directory for now (maybe there is some hack to get rid of the docs/ top level directory. Rebuilding Locally (debugging only) make a virtualenv publish with the command: portray on_github_pages Rebuild the portray virtualenv by simply installing portray and mkdocs-awesome-pages-plugin . Resources github pages quickstart","title":"Home"},{"location":"#gungheapcom","text":"This is a blog. \"Gung Heap\" is a quasi- portmanteau of \"Gung Ho\" and \"Dung Heap\". It is inspired by the Programmer Archaeologists of the Qeng Ho, pronounced Chung Ho (ref: \"A Fire Upon the Deep\", Vernor Vinge) and rhyming with \"Gung Ho\". The name is originally from our Noisebridge Gung Heap . I'm reusing it for my blog because I still like the name.","title":"gungheap.com"},{"location":"#github-pages","text":"The github pages are rendered with portray and mkdocs-awesome-pages-plugin Portray is configured in pyproject.toml requiring the project to have a docs directory for now (maybe there is some hack to get rid of the docs/ top level directory.","title":"Github Pages"},{"location":"#rebuilding-locally-debugging-only","text":"make a virtualenv publish with the command: portray on_github_pages Rebuild the portray virtualenv by simply installing portray and mkdocs-awesome-pages-plugin .","title":"Rebuilding Locally (debugging only)"},{"location":"#resources","text":"github pages quickstart","title":"Resources"},{"location":"docs/about/","text":"About Author: Trent Robbins","title":"About"},{"location":"docs/about/#about","text":"Author: Trent Robbins","title":"About"},{"location":"reference/portray/","text":"Module portray Sub-modules portray.api portray.cli portray.config portray.exceptions portray.logo portray.render","title":"Index"},{"location":"reference/portray/#module-portray","text":"","title":"Module portray"},{"location":"reference/portray/#sub-modules","text":"portray.api portray.cli portray.config portray.exceptions portray.logo portray.render","title":"Sub-modules"},{"location":"reference/portray/api/","text":"Module portray.api This module defines the programmatic API that can be used to interact with portray to generate and view documentation. If you want to extend portray or use it directly from within Python - this is the place to start. View Source \"\"\"This module defines the programmatic API that can be used to interact with `portray` to generate and view documentation. If you want to extend `portray` or use it directly from within Python - this is the place to start. \"\"\" import os import webbrowser from typing import Dict , Union import mkdocs.commands.gh_deploy from livereload import Server from portray import config , logo , render def as_html ( directory : str = \"\" , config_file : str = \"pyproject.toml\" , output_dir : str = \"site\" , overwrite : bool = False , modules : list = None , # type: ignore ) -> None : \"\"\"Produces HTML documentation for a Python project placing it into output_dir. - *directory*: The root folder of your project. - *config_file*: The [TOML](https://github.com/toml-lang/toml#toml) formatted config file you wish to use. - *output_dir*: The directory to place the generated HTML into. - *overwrite*: If set to `True` any existing documentation output will be removed before generating new documentation. Otherwise, if documentation exists in the specified `output_dir` the command will fail with a `DocumentationAlreadyExists` exception. - *modules*: One or more modules to render reference documentation for \"\"\" directory = directory if directory else os . getcwd () render . documentation ( project_configuration ( directory , config_file , modules = modules , output_dir = output_dir ), overwrite = overwrite , ) print ( logo . ascii_art ) print ( f \"Documentation successfully generated into ` { os . path . abspath ( output_dir ) } ` !\" ) def in_browser ( directory : str = \"\" , config_file : str = \"pyproject.toml\" , port : int = None , # type: ignore host : str = None , # type: ignore modules : list = None , # type: ignore reload : bool = False , ) -> None : \"\"\"Opens your default webbrowser pointing to a locally started development webserver enabling you to browse documentation locally - *directory*: The root folder of your project. - *config_file*: The [TOML](https://github.com/toml-lang/toml#toml) formatted config file you wish to use. - *port*: The port to expose your documentation on (defaults to: `8000`) - *host*: The host to expose your documentation on (defaults to `\"127.0.0.1\"`) - *modules*: One or more modules to render reference documentation for - *reload*: If true the server will live load any changes \"\"\" directory = directory if directory else os . getcwd () server ( directory = directory , config_file = config_file , open_browser = True , port = port , host = host , modules = modules , reload = reload , ) def server ( directory : str = \"\" , config_file : str = \"pyproject.toml\" , open_browser : bool = False , port : int = None , # type: ignore host : str = None , # type: ignore modules : list = None , # type: ignore reload : bool = False , ) -> None : \"\"\"Runs a development webserver enabling you to browse documentation locally. - *directory*: The root folder of your project. - *config_file*: The [TOML](https://github.com/toml-lang/toml#toml) formatted config file you wish to use. - *open_browser*: If true a browser will be opened pointing at the documentation server - *port*: The port to expose your documentation on (defaults to: `8000`) - *host*: The host to expose your documentation on (defaults to `\"127.0.0.1\"`) - *modules*: One or more modules to render reference documentation for - *reload*: If true the server will live load any changes \"\"\" directory = directory if directory else os . getcwd () project_config = project_configuration ( directory , config_file , modules = modules ) host = host or project_config [ \"host\" ] port = port or project_config [ \"port\" ] with render . documentation_in_temp_folder ( project_config ) as ( sources_folder , docs_folder ): print ( logo . ascii_art ) live_server = Server () if reload : def reloader (): # pragma: no cover sources_old = sources_folder + \".old\" docs_old = docs_folder + \".old\" with render . documentation_in_temp_folder ( project_config ) as ( sources_new , docs_new ): # cause as little churn as possible to the server watchers os . rename ( sources_folder , sources_old ) os . rename ( sources_new , sources_folder ) os . rename ( sources_old , sources_new ) os . rename ( docs_folder , docs_old ) os . rename ( docs_new , docs_folder ) os . rename ( docs_old , docs_new ) # all directories that feed documentation_in_temp_folder watch_dirs = set ( ( project_config [ \"directory\" ], project_config [ \"docs_dir\" ], * project_config [ \"extra_dirs\" ], ) ) if \"docs_dir\" in project_config [ \"mkdocs\" ]: watch_dirs . add ( project_config [ \"mkdocs\" ][ \"docs_dir\" ]) if \"site_dir\" in project_config [ \"mkdocs\" ]: watch_dirs . add ( project_config [ \"mkdocs\" ][ \"site_dir\" ]) for watch_dir in watch_dirs . difference ( set (( sources_folder , docs_folder ))): live_server . watch ( watch_dir , reloader ) if open_browser : webbrowser . open_new ( f \"http:// { host } : { port } \" ) live_server . serve ( root = docs_folder , host = host , port = port , restart_delay = 0 ) def project_configuration ( directory : str = \"\" , config_file : str = \"pyproject.toml\" , modules : list = None , # type: ignore output_dir : str = None , # type: ignore ) -> dict : \"\"\"Returns the configuration associated with a project. - *directory*: The root folder of your project. - *config_file*: The [TOML](https://github.com/toml-lang/toml#toml) formatted config file you wish to use. - *modules*: One or more modules to include in the configuration for reference rendering \"\"\" overrides : Dict [ str , Union [ str , list ]] = {} if modules : overrides [ \"modules\" ] = modules if output_dir : overrides [ \"output_dir\" ] = output_dir directory = directory if directory else os . getcwd () return config . project ( directory = directory , config_file = config_file , ** overrides ) def on_github_pages ( directory : str = \"\" , config_file : str = \"pyproject.toml\" , message : str = None , # type: ignore force : bool = False , ignore_version : bool = False , modules : list = None , # type: ignore ) -> None : \"\"\"Regenerates and deploys the documentation to GitHub pages. - *directory*: The root folder of your project. - *config_file*: The [TOML](https://github.com/toml-lang/toml#toml) formatted config file you wish to use. - *message*: The commit message to use when uploading your documentation. - *force*: Force the push to the repository. - *ignore_version*: Ignore check that build is not being deployed with an old version. - *modules*: One or more modules to render reference documentation for \"\"\" directory = directory if directory else os . getcwd () project_config = project_configuration ( directory , config_file , modules ) with render . documentation_in_temp_folder ( project_config ) as ( _ , site_dir ): project_config [ \"mkdocs\" ][ \"site_dir\" ] = site_dir conf = render . _mkdocs_config ( project_config [ \"mkdocs\" ]) conf . config_file_path = directory mkdocs . commands . gh_deploy . gh_deploy ( conf , message = message , force = force , ignore_version = ignore_version ) print ( logo . ascii_art ) print ( \"Documentation successfully generated and pushed!\" ) Functions as_html def as_html ( directory : str = '' , config_file : str = 'pyproject.toml' , output_dir : str = 'site' , overwrite : bool = False , modules : list = None ) -> None Produces HTML documentation for a Python project placing it into output_dir. directory : The root folder of your project. config_file : The TOML formatted config file you wish to use. output_dir : The directory to place the generated HTML into. overwrite : If set to True any existing documentation output will be removed before generating new documentation. Otherwise, if documentation exists in the specified output_dir the command will fail with a DocumentationAlreadyExists exception. modules : One or more modules to render reference documentation for View Source def as_html ( directory : str = \"\" , config_file : str = \"pyproject.toml\" , output_dir : str = \"site\" , overwrite : bool = False , modules : list = None , # type: ignore ) -> None : \" \"\" Produces HTML documentation for a Python project placing it into output_dir. - *directory*: The root folder of your project. - *config_file*: The [TOML](https://github.com/toml-lang/toml#toml) formatted config file you wish to use. - *output_dir*: The directory to place the generated HTML into. - *overwrite*: If set to `True` any existing documentation output will be removed before generating new documentation. Otherwise, if documentation exists in the specified `output_dir` the command will fail with a `DocumentationAlreadyExists` exception. - *modules*: One or more modules to render reference documentation for \"\" \" directory = directory if directory else os . getcwd () render . documentation ( project_configuration ( directory , config_file , modules = modules , output_dir = output_dir ), overwrite = overwrite , ) print ( logo . ascii_art ) print ( f \"Documentation successfully generated into `{os.path.abspath(output_dir)}` !\" ) in_browser def in_browser ( directory : str = '' , config_file : str = 'pyproject.toml' , port : int = None , host : str = None , modules : list = None , reload : bool = False ) -> None Opens your default webbrowser pointing to a locally started development webserver enabling you to browse documentation locally directory : The root folder of your project. config_file : The TOML formatted config file you wish to use. port : The port to expose your documentation on (defaults to: 8000 ) host : The host to expose your documentation on (defaults to \"127.0.0.1\" ) modules : One or more modules to render reference documentation for reload : If true the server will live load any changes View Source def in_browser ( directory : str = \"\" , config_file : str = \"pyproject.toml\" , port : int = None , # type : ignore host : str = None , # type : ignore modules : list = None , # type : ignore reload : bool = False , ) -> None : \"\"\"Opens your default webbrowser pointing to a locally started development webserver enabling you to browse documentation locally - *directory*: The root folder of your project. - *config_file*: The [TOML](https://github.com/toml-lang/toml#toml) formatted config file you wish to use. - *port*: The port to expose your documentation on (defaults to: `8000`) - *host*: The host to expose your documentation on (defaults to `\" 127.0.0.1 \"`) - *modules*: One or more modules to render reference documentation for - *reload*: If true the server will live load any changes \"\"\" directory = directory if directory else os . getcwd () server ( directory = directory , config_file = config_file , open_browser = True , port = port , host = host , modules = modules , reload = reload , ) on_github_pages def on_github_pages ( directory : str = '' , config_file : str = 'pyproject.toml' , message : str = None , force : bool = False , ignore_version : bool = False , modules : list = None ) -> None Regenerates and deploys the documentation to GitHub pages. directory : The root folder of your project. config_file : The TOML formatted config file you wish to use. message : The commit message to use when uploading your documentation. force : Force the push to the repository. ignore_version : Ignore check that build is not being deployed with an old version. modules : One or more modules to render reference documentation for View Source def on_github_pages ( directory : str = \"\" , config_file : str = \"pyproject.toml\" , message : str = None , # type : ignore force : bool = False , ignore_version : bool = False , modules : list = None , # type : ignore ) -> None : \"\"\"Regenerates and deploys the documentation to GitHub pages. - *directory*: The root folder of your project. - *config_file*: The [TOML](https://github.com/toml-lang/toml#toml) formatted config file you wish to use. - *message*: The commit message to use when uploading your documentation. - *force*: Force the push to the repository. - *ignore_version*: Ignore check that build is not being deployed with an old version. - *modules*: One or more modules to render reference documentation for \"\"\" directory = directory if directory else os . getcwd () project_config = project_configuration ( directory , config_file , modules ) with render . documentation_in_temp_folder ( project_config ) as ( _ , site_dir ) : project_config [ \"mkdocs\" ][ \"site_dir\" ] = site_dir conf = render . _mkdocs_config ( project_config [ \"mkdocs\" ] ) conf . config_file_path = directory mkdocs . commands . gh_deploy . gh_deploy ( conf , message = message , force = force , ignore_version = ignore_version ) print ( logo . ascii_art ) print ( \"Documentation successfully generated and pushed!\" ) project_configuration def project_configuration ( directory : str = '' , config_file : str = 'pyproject.toml' , modules : list = None , output_dir : str = None ) -> dict Returns the configuration associated with a project. directory : The root folder of your project. config_file : The TOML formatted config file you wish to use. modules : One or more modules to include in the configuration for reference rendering View Source def project_configuration ( directory : str = \"\" , config_file : str = \"pyproject.toml\" , modules : list = None , # type : ignore output_dir : str = None , # type : ignore ) -> dict : \"\"\"Returns the configuration associated with a project. - *directory*: The root folder of your project. - *config_file*: The [TOML](https://github.com/toml-lang/toml#toml) formatted config file you wish to use. - *modules*: One or more modules to include in the configuration for reference rendering \"\"\" overrides : Dict [ str, Union[str, list ] ] = {} if modules : overrides [ \"modules\" ] = modules if output_dir : overrides [ \"output_dir\" ] = output_dir directory = directory if directory else os . getcwd () return config . project ( directory = directory , config_file = config_file , ** overrides ) server def server ( directory : str = '' , config_file : str = 'pyproject.toml' , open_browser : bool = False , port : int = None , host : str = None , modules : list = None , reload : bool = False ) -> None Runs a development webserver enabling you to browse documentation locally. directory : The root folder of your project. config_file : The TOML formatted config file you wish to use. open_browser : If true a browser will be opened pointing at the documentation server port : The port to expose your documentation on (defaults to: 8000 ) host : The host to expose your documentation on (defaults to \"127.0.0.1\" ) modules : One or more modules to render reference documentation for reload : If true the server will live load any changes View Source def server ( directory : str = \"\" , config_file : str = \"pyproject.toml\" , open_browser : bool = False , port : int = None , # type : ignore host : str = None , # type : ignore modules : list = None , # type : ignore reload : bool = False , ) -> None : \"\"\"Runs a development webserver enabling you to browse documentation locally. - *directory*: The root folder of your project. - *config_file*: The [TOML](https://github.com/toml-lang/toml#toml) formatted config file you wish to use. - *open_browser*: If true a browser will be opened pointing at the documentation server - *port*: The port to expose your documentation on (defaults to: `8000`) - *host*: The host to expose your documentation on (defaults to `\" 127.0.0.1 \"`) - *modules*: One or more modules to render reference documentation for - *reload*: If true the server will live load any changes \"\"\" directory = directory if directory else os . getcwd () project_config = project_configuration ( directory , config_file , modules = modules ) host = host or project_config [ \"host\" ] port = port or project_config [ \"port\" ] with render . documentation_in_temp_folder ( project_config ) as ( sources_folder , docs_folder ) : print ( logo . ascii_art ) live_server = Server () if reload : def reloader () : # pragma : no cover sources_old = sources_folder + \".old\" docs_old = docs_folder + \".old\" with render . documentation_in_temp_folder ( project_config ) as ( sources_new , docs_new ) : # cause as little churn as possible to the server watchers os . rename ( sources_folder , sources_old ) os . rename ( sources_new , sources_folder ) os . rename ( sources_old , sources_new ) os . rename ( docs_folder , docs_old ) os . rename ( docs_new , docs_folder ) os . rename ( docs_old , docs_new ) # all directories that feed documentation_in_temp_folder watch_dirs = set ( ( project_config [ \"directory\" ] , project_config [ \"docs_dir\" ] , * project_config [ \"extra_dirs\" ] , ) ) if \"docs_dir\" in project_config [ \"mkdocs\" ] : watch_dirs . add ( project_config [ \"mkdocs\" ][ \"docs_dir\" ] ) if \"site_dir\" in project_config [ \"mkdocs\" ] : watch_dirs . add ( project_config [ \"mkdocs\" ][ \"site_dir\" ] ) for watch_dir in watch_dirs . difference ( set (( sources_folder , docs_folder ))) : live_server . watch ( watch_dir , reloader ) if open_browser : webbrowser . open_new ( f \"http://{host}:{port}\" ) live_server . serve ( root = docs_folder , host = host , port = port , restart_delay = 0 )","title":"API"},{"location":"reference/portray/api/#module-portrayapi","text":"This module defines the programmatic API that can be used to interact with portray to generate and view documentation. If you want to extend portray or use it directly from within Python - this is the place to start. View Source \"\"\"This module defines the programmatic API that can be used to interact with `portray` to generate and view documentation. If you want to extend `portray` or use it directly from within Python - this is the place to start. \"\"\" import os import webbrowser from typing import Dict , Union import mkdocs.commands.gh_deploy from livereload import Server from portray import config , logo , render def as_html ( directory : str = \"\" , config_file : str = \"pyproject.toml\" , output_dir : str = \"site\" , overwrite : bool = False , modules : list = None , # type: ignore ) -> None : \"\"\"Produces HTML documentation for a Python project placing it into output_dir. - *directory*: The root folder of your project. - *config_file*: The [TOML](https://github.com/toml-lang/toml#toml) formatted config file you wish to use. - *output_dir*: The directory to place the generated HTML into. - *overwrite*: If set to `True` any existing documentation output will be removed before generating new documentation. Otherwise, if documentation exists in the specified `output_dir` the command will fail with a `DocumentationAlreadyExists` exception. - *modules*: One or more modules to render reference documentation for \"\"\" directory = directory if directory else os . getcwd () render . documentation ( project_configuration ( directory , config_file , modules = modules , output_dir = output_dir ), overwrite = overwrite , ) print ( logo . ascii_art ) print ( f \"Documentation successfully generated into ` { os . path . abspath ( output_dir ) } ` !\" ) def in_browser ( directory : str = \"\" , config_file : str = \"pyproject.toml\" , port : int = None , # type: ignore host : str = None , # type: ignore modules : list = None , # type: ignore reload : bool = False , ) -> None : \"\"\"Opens your default webbrowser pointing to a locally started development webserver enabling you to browse documentation locally - *directory*: The root folder of your project. - *config_file*: The [TOML](https://github.com/toml-lang/toml#toml) formatted config file you wish to use. - *port*: The port to expose your documentation on (defaults to: `8000`) - *host*: The host to expose your documentation on (defaults to `\"127.0.0.1\"`) - *modules*: One or more modules to render reference documentation for - *reload*: If true the server will live load any changes \"\"\" directory = directory if directory else os . getcwd () server ( directory = directory , config_file = config_file , open_browser = True , port = port , host = host , modules = modules , reload = reload , ) def server ( directory : str = \"\" , config_file : str = \"pyproject.toml\" , open_browser : bool = False , port : int = None , # type: ignore host : str = None , # type: ignore modules : list = None , # type: ignore reload : bool = False , ) -> None : \"\"\"Runs a development webserver enabling you to browse documentation locally. - *directory*: The root folder of your project. - *config_file*: The [TOML](https://github.com/toml-lang/toml#toml) formatted config file you wish to use. - *open_browser*: If true a browser will be opened pointing at the documentation server - *port*: The port to expose your documentation on (defaults to: `8000`) - *host*: The host to expose your documentation on (defaults to `\"127.0.0.1\"`) - *modules*: One or more modules to render reference documentation for - *reload*: If true the server will live load any changes \"\"\" directory = directory if directory else os . getcwd () project_config = project_configuration ( directory , config_file , modules = modules ) host = host or project_config [ \"host\" ] port = port or project_config [ \"port\" ] with render . documentation_in_temp_folder ( project_config ) as ( sources_folder , docs_folder ): print ( logo . ascii_art ) live_server = Server () if reload : def reloader (): # pragma: no cover sources_old = sources_folder + \".old\" docs_old = docs_folder + \".old\" with render . documentation_in_temp_folder ( project_config ) as ( sources_new , docs_new ): # cause as little churn as possible to the server watchers os . rename ( sources_folder , sources_old ) os . rename ( sources_new , sources_folder ) os . rename ( sources_old , sources_new ) os . rename ( docs_folder , docs_old ) os . rename ( docs_new , docs_folder ) os . rename ( docs_old , docs_new ) # all directories that feed documentation_in_temp_folder watch_dirs = set ( ( project_config [ \"directory\" ], project_config [ \"docs_dir\" ], * project_config [ \"extra_dirs\" ], ) ) if \"docs_dir\" in project_config [ \"mkdocs\" ]: watch_dirs . add ( project_config [ \"mkdocs\" ][ \"docs_dir\" ]) if \"site_dir\" in project_config [ \"mkdocs\" ]: watch_dirs . add ( project_config [ \"mkdocs\" ][ \"site_dir\" ]) for watch_dir in watch_dirs . difference ( set (( sources_folder , docs_folder ))): live_server . watch ( watch_dir , reloader ) if open_browser : webbrowser . open_new ( f \"http:// { host } : { port } \" ) live_server . serve ( root = docs_folder , host = host , port = port , restart_delay = 0 ) def project_configuration ( directory : str = \"\" , config_file : str = \"pyproject.toml\" , modules : list = None , # type: ignore output_dir : str = None , # type: ignore ) -> dict : \"\"\"Returns the configuration associated with a project. - *directory*: The root folder of your project. - *config_file*: The [TOML](https://github.com/toml-lang/toml#toml) formatted config file you wish to use. - *modules*: One or more modules to include in the configuration for reference rendering \"\"\" overrides : Dict [ str , Union [ str , list ]] = {} if modules : overrides [ \"modules\" ] = modules if output_dir : overrides [ \"output_dir\" ] = output_dir directory = directory if directory else os . getcwd () return config . project ( directory = directory , config_file = config_file , ** overrides ) def on_github_pages ( directory : str = \"\" , config_file : str = \"pyproject.toml\" , message : str = None , # type: ignore force : bool = False , ignore_version : bool = False , modules : list = None , # type: ignore ) -> None : \"\"\"Regenerates and deploys the documentation to GitHub pages. - *directory*: The root folder of your project. - *config_file*: The [TOML](https://github.com/toml-lang/toml#toml) formatted config file you wish to use. - *message*: The commit message to use when uploading your documentation. - *force*: Force the push to the repository. - *ignore_version*: Ignore check that build is not being deployed with an old version. - *modules*: One or more modules to render reference documentation for \"\"\" directory = directory if directory else os . getcwd () project_config = project_configuration ( directory , config_file , modules ) with render . documentation_in_temp_folder ( project_config ) as ( _ , site_dir ): project_config [ \"mkdocs\" ][ \"site_dir\" ] = site_dir conf = render . _mkdocs_config ( project_config [ \"mkdocs\" ]) conf . config_file_path = directory mkdocs . commands . gh_deploy . gh_deploy ( conf , message = message , force = force , ignore_version = ignore_version ) print ( logo . ascii_art ) print ( \"Documentation successfully generated and pushed!\" )","title":"Module portray.api"},{"location":"reference/portray/api/#functions","text":"","title":"Functions"},{"location":"reference/portray/api/#as_html","text":"def as_html ( directory : str = '' , config_file : str = 'pyproject.toml' , output_dir : str = 'site' , overwrite : bool = False , modules : list = None ) -> None Produces HTML documentation for a Python project placing it into output_dir. directory : The root folder of your project. config_file : The TOML formatted config file you wish to use. output_dir : The directory to place the generated HTML into. overwrite : If set to True any existing documentation output will be removed before generating new documentation. Otherwise, if documentation exists in the specified output_dir the command will fail with a DocumentationAlreadyExists exception. modules : One or more modules to render reference documentation for View Source def as_html ( directory : str = \"\" , config_file : str = \"pyproject.toml\" , output_dir : str = \"site\" , overwrite : bool = False , modules : list = None , # type: ignore ) -> None : \" \"\" Produces HTML documentation for a Python project placing it into output_dir. - *directory*: The root folder of your project. - *config_file*: The [TOML](https://github.com/toml-lang/toml#toml) formatted config file you wish to use. - *output_dir*: The directory to place the generated HTML into. - *overwrite*: If set to `True` any existing documentation output will be removed before generating new documentation. Otherwise, if documentation exists in the specified `output_dir` the command will fail with a `DocumentationAlreadyExists` exception. - *modules*: One or more modules to render reference documentation for \"\" \" directory = directory if directory else os . getcwd () render . documentation ( project_configuration ( directory , config_file , modules = modules , output_dir = output_dir ), overwrite = overwrite , ) print ( logo . ascii_art ) print ( f \"Documentation successfully generated into `{os.path.abspath(output_dir)}` !\" )","title":"as_html"},{"location":"reference/portray/api/#in_browser","text":"def in_browser ( directory : str = '' , config_file : str = 'pyproject.toml' , port : int = None , host : str = None , modules : list = None , reload : bool = False ) -> None Opens your default webbrowser pointing to a locally started development webserver enabling you to browse documentation locally directory : The root folder of your project. config_file : The TOML formatted config file you wish to use. port : The port to expose your documentation on (defaults to: 8000 ) host : The host to expose your documentation on (defaults to \"127.0.0.1\" ) modules : One or more modules to render reference documentation for reload : If true the server will live load any changes View Source def in_browser ( directory : str = \"\" , config_file : str = \"pyproject.toml\" , port : int = None , # type : ignore host : str = None , # type : ignore modules : list = None , # type : ignore reload : bool = False , ) -> None : \"\"\"Opens your default webbrowser pointing to a locally started development webserver enabling you to browse documentation locally - *directory*: The root folder of your project. - *config_file*: The [TOML](https://github.com/toml-lang/toml#toml) formatted config file you wish to use. - *port*: The port to expose your documentation on (defaults to: `8000`) - *host*: The host to expose your documentation on (defaults to `\" 127.0.0.1 \"`) - *modules*: One or more modules to render reference documentation for - *reload*: If true the server will live load any changes \"\"\" directory = directory if directory else os . getcwd () server ( directory = directory , config_file = config_file , open_browser = True , port = port , host = host , modules = modules , reload = reload , )","title":"in_browser"},{"location":"reference/portray/api/#on_github_pages","text":"def on_github_pages ( directory : str = '' , config_file : str = 'pyproject.toml' , message : str = None , force : bool = False , ignore_version : bool = False , modules : list = None ) -> None Regenerates and deploys the documentation to GitHub pages. directory : The root folder of your project. config_file : The TOML formatted config file you wish to use. message : The commit message to use when uploading your documentation. force : Force the push to the repository. ignore_version : Ignore check that build is not being deployed with an old version. modules : One or more modules to render reference documentation for View Source def on_github_pages ( directory : str = \"\" , config_file : str = \"pyproject.toml\" , message : str = None , # type : ignore force : bool = False , ignore_version : bool = False , modules : list = None , # type : ignore ) -> None : \"\"\"Regenerates and deploys the documentation to GitHub pages. - *directory*: The root folder of your project. - *config_file*: The [TOML](https://github.com/toml-lang/toml#toml) formatted config file you wish to use. - *message*: The commit message to use when uploading your documentation. - *force*: Force the push to the repository. - *ignore_version*: Ignore check that build is not being deployed with an old version. - *modules*: One or more modules to render reference documentation for \"\"\" directory = directory if directory else os . getcwd () project_config = project_configuration ( directory , config_file , modules ) with render . documentation_in_temp_folder ( project_config ) as ( _ , site_dir ) : project_config [ \"mkdocs\" ][ \"site_dir\" ] = site_dir conf = render . _mkdocs_config ( project_config [ \"mkdocs\" ] ) conf . config_file_path = directory mkdocs . commands . gh_deploy . gh_deploy ( conf , message = message , force = force , ignore_version = ignore_version ) print ( logo . ascii_art ) print ( \"Documentation successfully generated and pushed!\" )","title":"on_github_pages"},{"location":"reference/portray/api/#project_configuration","text":"def project_configuration ( directory : str = '' , config_file : str = 'pyproject.toml' , modules : list = None , output_dir : str = None ) -> dict Returns the configuration associated with a project. directory : The root folder of your project. config_file : The TOML formatted config file you wish to use. modules : One or more modules to include in the configuration for reference rendering View Source def project_configuration ( directory : str = \"\" , config_file : str = \"pyproject.toml\" , modules : list = None , # type : ignore output_dir : str = None , # type : ignore ) -> dict : \"\"\"Returns the configuration associated with a project. - *directory*: The root folder of your project. - *config_file*: The [TOML](https://github.com/toml-lang/toml#toml) formatted config file you wish to use. - *modules*: One or more modules to include in the configuration for reference rendering \"\"\" overrides : Dict [ str, Union[str, list ] ] = {} if modules : overrides [ \"modules\" ] = modules if output_dir : overrides [ \"output_dir\" ] = output_dir directory = directory if directory else os . getcwd () return config . project ( directory = directory , config_file = config_file , ** overrides )","title":"project_configuration"},{"location":"reference/portray/api/#server","text":"def server ( directory : str = '' , config_file : str = 'pyproject.toml' , open_browser : bool = False , port : int = None , host : str = None , modules : list = None , reload : bool = False ) -> None Runs a development webserver enabling you to browse documentation locally. directory : The root folder of your project. config_file : The TOML formatted config file you wish to use. open_browser : If true a browser will be opened pointing at the documentation server port : The port to expose your documentation on (defaults to: 8000 ) host : The host to expose your documentation on (defaults to \"127.0.0.1\" ) modules : One or more modules to render reference documentation for reload : If true the server will live load any changes View Source def server ( directory : str = \"\" , config_file : str = \"pyproject.toml\" , open_browser : bool = False , port : int = None , # type : ignore host : str = None , # type : ignore modules : list = None , # type : ignore reload : bool = False , ) -> None : \"\"\"Runs a development webserver enabling you to browse documentation locally. - *directory*: The root folder of your project. - *config_file*: The [TOML](https://github.com/toml-lang/toml#toml) formatted config file you wish to use. - *open_browser*: If true a browser will be opened pointing at the documentation server - *port*: The port to expose your documentation on (defaults to: `8000`) - *host*: The host to expose your documentation on (defaults to `\" 127.0.0.1 \"`) - *modules*: One or more modules to render reference documentation for - *reload*: If true the server will live load any changes \"\"\" directory = directory if directory else os . getcwd () project_config = project_configuration ( directory , config_file , modules = modules ) host = host or project_config [ \"host\" ] port = port or project_config [ \"port\" ] with render . documentation_in_temp_folder ( project_config ) as ( sources_folder , docs_folder ) : print ( logo . ascii_art ) live_server = Server () if reload : def reloader () : # pragma : no cover sources_old = sources_folder + \".old\" docs_old = docs_folder + \".old\" with render . documentation_in_temp_folder ( project_config ) as ( sources_new , docs_new ) : # cause as little churn as possible to the server watchers os . rename ( sources_folder , sources_old ) os . rename ( sources_new , sources_folder ) os . rename ( sources_old , sources_new ) os . rename ( docs_folder , docs_old ) os . rename ( docs_new , docs_folder ) os . rename ( docs_old , docs_new ) # all directories that feed documentation_in_temp_folder watch_dirs = set ( ( project_config [ \"directory\" ] , project_config [ \"docs_dir\" ] , * project_config [ \"extra_dirs\" ] , ) ) if \"docs_dir\" in project_config [ \"mkdocs\" ] : watch_dirs . add ( project_config [ \"mkdocs\" ][ \"docs_dir\" ] ) if \"site_dir\" in project_config [ \"mkdocs\" ] : watch_dirs . add ( project_config [ \"mkdocs\" ][ \"site_dir\" ] ) for watch_dir in watch_dirs . difference ( set (( sources_folder , docs_folder ))) : live_server . watch ( watch_dir , reloader ) if open_browser : webbrowser . open_new ( f \"http://{host}:{port}\" ) live_server . serve ( root = docs_folder , host = host , port = port , restart_delay = 0 )","title":"server"},{"location":"reference/portray/cli/","text":"Module portray.cli This module defines CLI interaction when using portray . This is powered by hug which means unless necessary it should maintain 1:1 compatibility with the programmatic API definition in the API module portray as_html : Renders the project as HTML into the site or other specified output directory portray in_browser : Runs a server with the rendered documentation pointing a browser to it portray server : Starts a local development server (by default at localhost:8000) portray project_configuration : Returns back the project configuration as determined by portray View Source \"\"\"This module defines CLI interaction when using `portray`. This is powered by [hug](https://github.com/hugapi/hug) which means unless necessary it should maintain 1:1 compatibility with the programmatic API definition in the [API module](/reference/portray/api) - `portray as_html`: Renders the project as HTML into the `site` or other specified output directory - `portray in_browser`: Runs a server with the rendered documentation pointing a browser to it - `portray server`: Starts a local development server (by default at localhost:8000) - `portray project_configuration`: Returns back the project configuration as determined by` portray` \"\"\" from pprint import pprint import hug from portray import api , logo cli = hug . cli ( api = hug . API ( __name__ , doc = logo . ascii_art )) cli ( api . as_html ) cli . output ( pprint )( api . project_configuration ) cli ( api . server ) cli ( api . in_browser ) cli ( api . on_github_pages ) Variables cli","title":"CLI"},{"location":"reference/portray/cli/#module-portraycli","text":"This module defines CLI interaction when using portray . This is powered by hug which means unless necessary it should maintain 1:1 compatibility with the programmatic API definition in the API module portray as_html : Renders the project as HTML into the site or other specified output directory portray in_browser : Runs a server with the rendered documentation pointing a browser to it portray server : Starts a local development server (by default at localhost:8000) portray project_configuration : Returns back the project configuration as determined by portray View Source \"\"\"This module defines CLI interaction when using `portray`. This is powered by [hug](https://github.com/hugapi/hug) which means unless necessary it should maintain 1:1 compatibility with the programmatic API definition in the [API module](/reference/portray/api) - `portray as_html`: Renders the project as HTML into the `site` or other specified output directory - `portray in_browser`: Runs a server with the rendered documentation pointing a browser to it - `portray server`: Starts a local development server (by default at localhost:8000) - `portray project_configuration`: Returns back the project configuration as determined by` portray` \"\"\" from pprint import pprint import hug from portray import api , logo cli = hug . cli ( api = hug . API ( __name__ , doc = logo . ascii_art )) cli ( api . as_html ) cli . output ( pprint )( api . project_configuration ) cli ( api . server ) cli ( api . in_browser ) cli ( api . on_github_pages )","title":"Module portray.cli"},{"location":"reference/portray/cli/#variables","text":"cli","title":"Variables"},{"location":"reference/portray/config/","text":"Module portray.config Defines the configuration defaults and load functions used by portray View Source \"\"\"Defines the configuration defaults and load functions used by `portray`\"\"\" import _ast import ast import os import re import warnings from pathlib import Path from typing import Any , Dict , Optional import mkdocs.config as _mkdocs_config # noqa import mkdocs.exceptions as _mkdocs_exceptions # noqa from git import Repo from toml import load as toml_load from portray.exceptions import NoProjectFound PORTRAY_DEFAULTS = { \"docs_dir\" : \"docs\" , \"extra_dirs\" : [ \"art\" , \"images\" , \"media\" ], \"output_dir\" : \"site\" , \"port\" : 8000 , \"host\" : \"127.0.0.1\" , \"append_directory_to_python_path\" : True , \"include_reference_documentation\" : True , \"labels\" : { \"Cli\" : \"CLI\" , \"Api\" : \"API\" , \"Http\" : \"HTTP\" , \"Pypi\" : \"PyPI\" }, \"extra_markdown_extensions\" : [], } MKDOCS_DEFAULTS : Dict [ str , Any ] = { \"site_name\" : os . path . basename ( os . getcwd ()), \"config_file_path\" : os . getcwd (), \"theme\" : { \"name\" : \"material\" , \"palette\" : { \"primary\" : \"green\" , \"accent\" : \"lightgreen\" }, \"custom_dir\" : os . path . join ( os . path . dirname ( __file__ ), \"mkdocs_templates\" ), }, \"markdown_extensions\" : [ \"admonition\" , \"codehilite\" , \"extra\" , \"pymdownx.details\" , \"pymdownx.highlight\" , ], } PDOCS_DEFAULTS : Dict = { \"overwrite\" : True , \"exclude_source\" : False } def project ( directory : str , config_file : str , ** overrides ) -> dict : \"\"\"Returns back the complete configuration - including all sub configuration components defined below that `portray` was able to determine for the project \"\"\" if not ( os . path . isfile ( os . path . join ( directory , config_file )) or os . path . isfile ( os . path . join ( directory , \"setup.py\" )) or \"modules\" in overrides ): raise NoProjectFound ( directory ) project_config : Dict [ str , Any ] = { ** PORTRAY_DEFAULTS , \"directory\" : directory } if os . path . isfile ( os . path . join ( directory , \"setup.py\" )): project_config . update ( setup_py ( os . path . join ( directory , \"setup.py\" ))) project_config . update ( toml ( os . path . join ( directory , config_file ))) project_config . update ( overrides ) project_config . setdefault ( \"modules\" , [ os . path . basename ( os . getcwd ()) . replace ( \"-\" , \"_\" )]) project_config . setdefault ( \"pdocs\" , {}) . setdefault ( \"modules\" , project_config [ \"modules\" ]) mkdocs_config = project_config . get ( \"mkdocs\" , {}) mkdocs_config . setdefault ( \"extra_markdown_extensions\" , project_config . get ( \"extra_markdown_extensions\" , []) ) project_config [ \"mkdocs\" ] = mkdocs ( directory , ** mkdocs_config ) if \"pdoc3\" in project_config : warnings . warn ( \"pdoc3 config usage is deprecated in favor of pdocs. \" \"pdoc3 section will be ignored. \" , DeprecationWarning , ) project_config [ \"pdocs\" ] = pdocs ( directory , ** project_config . get ( \"pdocs\" , {})) return project_config def setup_py ( location : str ) -> dict : \"\"\"Returns back any configuration info we are able to determine from a setup.py file\"\"\" setup_config = {} try : with open ( location ) as setup_py_file : for node in ast . walk ( ast . parse ( setup_py_file . read ())): if ( type ( node ) == _ast . Call and type ( getattr ( node , \"func\" , None )) == _ast . Name and node . func . id == \"setup\" # type: ignore ): for keyword in node . keywords : # type: ignore if keyword . arg == \"packages\" : setup_config [ \"modules\" ] = ast . literal_eval ( keyword . value ) break break except Exception as error : warnings . warn ( f \"Error ( { error } ) occurred trying to parse setup.py file: { location } \" ) return setup_config def toml ( location : str ) -> dict : \"\"\"Returns back the configuration found within the projects [TOML](https://github.com/toml-lang/toml#toml) config (if there is one). Generally this is a `pyproject.toml` file at the root of the project with a `[tool.portray]` section defined. \"\"\" try : location_exists = os . path . exists ( location ) if not location_exists : warnings . warn ( f ' \\n No config file found at location: \" { location } \"' ) return {} except Exception as detection_error : # pragma: no cover warnings . warn ( f ' \\n Unable to check config at \" { location } \" due to error: { detection_error } ' ) try : toml_config = toml_load ( location ) tools = toml_config . get ( \"tool\" , {}) config = tools . get ( \"portray\" , {}) config [ \"file\" ] = location if \"modules\" not in config : if \"poetry\" in tools and \"name\" in tools [ \"poetry\" ]: config [ \"modules\" ] = [ tools [ \"poetry\" ][ \"name\" ]] elif ( \"flit\" in tools and \"metadata\" in tools [ \"flit\" ] and \"module\" in tools [ \"flit\" ][ \"metadata\" ] ): config [ \"modules\" ] = [ tools [ \"flit\" ][ \"metadata\" ][ \"module\" ]] return config except Exception as load_config_error : warnings . warn ( f ' \\n Config file at \" { location } \" has errors: { load_config_error } ' ) return {} def repository ( directory : str , repo_url : Optional [ str ] = None , repo_name : Optional [ str ] = None , edit_uri : Optional [ str ] = None , normalize_repo_url : bool = True , ** kwargs , ) -> Dict [ str , Optional [ str ]]: \"\"\"Returns back any information that can be determined by introspecting the projects git repo (if there is one). \"\"\" try : if repo_url is None : repo_url = Repo ( directory ) . remotes . origin . url if repo_name is None : match = re . search ( r \"(:(//)?)([\\w\\.@\\:/\\-~]+)(\\.git)?(/)?\" , repo_url ) if match : path = match . groups ()[ 2 ] else : path = repo_url repo_name = path . split ( \"/\" )[ - 1 ] if repo_name . endswith ( \".git\" ): repo_name = repo_name [: - len ( \".git\" )] if edit_uri is None : if \"github\" in repo_url or \"gitlab\" in repo_url : edit_uri = \"edit/main/\" elif \"bitbucket\" in repo_url : edit_uri = \"src/default/docs/\" if normalize_repo_url : if repo_url . startswith ( \"git@\" ) and \":\" in repo_url : tld , path = repo_url [ 4 :] . split ( \":\" ) repo_url = f \"https:// { tld } / { path } \" elif repo_url . startswith ( \"https://\" ) and \"@\" in repo_url : repo_url = f \"https:// { repo_url . split ( '@' )[ 1 ] } \" if repo_url and \"github\" in repo_url or \"gitlab\" in repo_url or \"bitbucket\" in repo_url : repo_url = repo_url . replace ( \".git\" , \"\" ) return { key : value for key , value in { \"repo_url\" : repo_url , \"repo_name\" : repo_name , \"edit_uri\" : edit_uri , } . items () if value } except Exception : warnings . warn ( \"Unable to identify `repo_name`, `repo_url`, and `edit_uri` automatically.\" ) return {} def mkdocs ( directory : str , ** overrides ) -> dict : \"\"\"Returns back the configuration that will be used when running mkdocs\"\"\" mkdocs_config : Dict [ str , Any ] = { ** MKDOCS_DEFAULTS , ** repository ( directory , ** overrides ), ** overrides , } theme = mkdocs_config [ \"theme\" ] if theme [ \"name\" ] . lower () == \"material\" : if \"custom_dir\" in theme : theme [ \"custom_dir\" ] = Path ( theme [ \"custom_dir\" ]) . absolute () . as_posix () else : theme [ \"custom_dir\" ] = MKDOCS_DEFAULTS [ \"theme\" ][ \"custom_dir\" ] nav = mkdocs_config . get ( \"nav\" , None ) if nav and hasattr ( nav [ 0 ], \"copy\" ): mkdocs_config [ \"nav\" ] = [ nav_item . copy () for nav_item in nav ] mkdocs_config [ \"markdown_extensions\" ] = mkdocs_config [ \"markdown_extensions\" ] + mkdocs_config . pop ( \"extra_markdown_extensions\" , [] ) return mkdocs_config def pdocs ( directory : str , ** overrides ) -> dict : \"\"\"Returns back the configuration that will be used when running pdocs\"\"\" defaults = { ** PDOCS_DEFAULTS } defaults . update ( overrides ) return defaults Variables MKDOCS_DEFAULTS PDOCS_DEFAULTS PORTRAY_DEFAULTS Functions mkdocs def mkdocs ( directory : str , ** overrides ) -> dict Returns back the configuration that will be used when running mkdocs View Source def mkdocs ( directory : str , ** overrides ) -> dict : \"\"\"Returns back the configuration that will be used when running mkdocs\"\"\" mkdocs_config : Dict [ str , Any ] = { ** MKDOCS_DEFAULTS , ** repository ( directory , ** overrides ), ** overrides , } theme = mkdocs_config [ \"theme\" ] if theme [ \"name\" ]. lower () == \"material\" : if \"custom_dir\" in theme : theme [ \"custom_dir\" ] = Path ( theme [ \"custom_dir\" ]). absolute (). as_posix () else : theme [ \"custom_dir\" ] = MKDOCS_DEFAULTS [ \"theme\" ][ \"custom_dir\" ] nav = mkdocs_config . get ( \"nav\" , None ) if nav and hasattr ( nav [ 0 ], \"copy\" ) : mkdocs_config [ \"nav\" ] = [ nav_item . copy () for nav_item in nav ] mkdocs_config [ \"markdown_extensions\" ] = mkdocs_config [ \"markdown_extensions\" ] + mkdocs_config . pop ( \"extra_markdown_extensions\" , [] ) return mkdocs_config pdocs def pdocs ( directory : str , ** overrides ) -> dict Returns back the configuration that will be used when running pdocs View Source def pdocs ( directory : str , ** overrides ) -> dict : \"\"\"Returns back the configuration that will be used when running pdocs\"\"\" defaults = { ** PDOCS_DEFAULTS } defaults . update ( overrides ) return defaults project def project ( directory : str , config_file : str , ** overrides ) -> dict Returns back the complete configuration - including all sub configuration components defined below that portray was able to determine for the project View Source def project ( directory : str , config_file : str , ** overrides ) -> dict : \" \"\" Returns back the complete configuration - including all sub configuration components defined below that `portray` was able to determine for the project \"\" \" if not ( os . path . isfile ( os . path . join ( directory , config_file )) or os . path . isfile ( os . path . join ( directory , \"setup.py\" )) or \"modules\" in overrides ) : raise NoProjectFound ( directory ) project_config : Dict [ str , Any ] = { ** PORTRAY_DEFAULTS , \"directory\" : directory } if os . path . isfile ( os . path . join ( directory , \"setup.py\" )) : project_config . update ( set up_py ( os . path . join ( directory , \"setup.py\" ))) project_config . update ( toml ( os . path . join ( directory , config_file ))) project_config . update ( overrides ) project_config . set default ( \"modules\" , [ os . path . basename ( os . getcwd ()). replace ( \"-\" , \"_\" ) ] ) project_config . set default ( \"pdocs\" , {} ). set default ( \"modules\" , project_config [ \"modules\" ] ) mkdocs_config = project_config . get ( \"mkdocs\" , {} ) mkdocs_config . set default ( \"extra_markdown_extensions\" , project_config . get ( \"extra_markdown_extensions\" , [] ) ) project_config [ \"mkdocs\" ] = mkdocs ( directory , ** mkdocs_config ) if \"pdoc3\" in project_config : warnings . warn ( \"pdoc3 config usage is deprecated in favor of pdocs. \" \"pdoc3 section will be ignored. \" , DeprecationWarning , ) project_config [ \"pdocs\" ] = pdocs ( directory , ** project_config . get ( \"pdocs\" , {} )) return project_config repository def repository ( directory : str , repo_url : Union [ str , NoneType ] = None , repo_name : Union [ str , NoneType ] = None , edit_uri : Union [ str , NoneType ] = None , normalize_repo_url : bool = True , ** kwargs ) -> Dict [ str , Union [ str , NoneType ]] Returns back any information that can be determined by introspecting the projects git repo (if there is one). View Source def repository ( directory : str , repo_url : Optional [ str ] = None , repo_name : Optional [ str ] = None , edit_uri : Optional [ str ] = None , normalize_repo_url : bool = True , ** kwargs , ) -> Dict [ str , Optional [ str ]] : \"\"\"Returns back any information that can be determined by introspecting the projects git repo ( if there is one ). \"\"\" try : if repo_url is None : repo_url = Repo ( directory ). remotes . origin . url if repo_name is None : match = re . search ( r \"(:(//)?)([\\w\\.@\\:/\\-~]+)(\\.git)?(/)?\" , repo_url ) if match : path = match . groups ()[ 2 ] else : path = repo_url repo_name = path . split ( \"/\" )[ -1 ] if repo_name . endswith ( \".git\" ) : repo_name = repo_name [ : - len ( \".git\" )] if edit_uri is None : if \"github\" in repo_url or \"gitlab\" in repo_url : edit_uri = \"edit/main/\" elif \"bitbucket\" in repo_url : edit_uri = \"src/default/docs/\" if normalize_repo_url : if repo_url . startswith ( \"git@\" ) and \":\" in repo_url : tld , path = repo_url [ 4 : ]. split ( \":\" ) repo_url = f \"https://{tld}/{path}\" elif repo_url . startswith ( \"https://\" ) and \"@\" in repo_url : repo_url = f \"https://{repo_url.split('@')[1]}\" if repo_url and \"github\" in repo_url or \"gitlab\" in repo_url or \"bitbucket\" in repo_url : repo_url = repo_url . replace ( \".git\" , \"\" ) return { key : value for key , value in { \"repo_url\" : repo_url , \"repo_name\" : repo_name , \"edit_uri\" : edit_uri , }. items () if value } except Exception : warnings . warn ( \"Unable to identify `repo_name`, `repo_url`, and `edit_uri` automatically.\" ) return {} setup_py def setup_py ( location : str ) -> dict Returns back any configuration info we are able to determine from a setup.py file View Source def setup_py ( location : str ) -> dict : \"\"\"Returns back any configuration info we are able to determine from a setup.py file\"\"\" setup_config = {} try : with open ( location ) as setup_py_file : for node in ast . walk ( ast . parse ( setup_py_file . read ())) : if ( type ( node ) == _ast . Call and type ( getattr ( node , \"func\" , None )) == _ast . Name and node . func . id == \"setup\" # type : ignore ) : for keyword in node . keywords : # type : ignore if keyword . arg == \"packages\" : setup_config [ \"modules\" ] = ast . literal_eval ( keyword . value ) break break except Exception as error : warnings . warn ( f \"Error ({error}) occurred trying to parse setup.py file: {location}\" ) return setup_config toml def toml ( location : str ) -> dict Returns back the configuration found within the projects TOML config (if there is one). Generally this is a pyproject.toml file at the root of the project with a [tool.portray] section defined. View Source def toml ( location : str ) -> dict : \"\"\"Returns back the configuration found within the projects [TOML](https://github.com/toml-lang/toml#toml) config (if there is one). Generally this is a `pyproject.toml` file at the root of the project with a `[tool.portray]` section defined. \"\"\" try : location_exists = os . path . exists ( location ) if not location_exists : warnings . warn ( f ' \\n No config file found at location: \"{location}\"' ) return {} except Exception as detection_error : # pragma: no cover warnings . warn ( f ' \\n Unable to check config at \"{location}\" due to error: {detection_error}' ) try : toml_config = toml_load ( location ) tools = toml_config . get ( \"tool\" , {}) config = tools . get ( \"portray\" , {}) config [ \"file\" ] = location if \"modules\" not in config : if \"poetry\" in tools and \"name\" in tools [ \"poetry\" ]: config [ \"modules\" ] = [ tools [ \"poetry\" ][ \"name\" ]] elif ( \"flit\" in tools and \"metadata\" in tools [ \"flit\" ] and \"module\" in tools [ \"flit\" ][ \"metadata\" ] ): config [ \"modules\" ] = [ tools [ \"flit\" ][ \"metadata\" ][ \"module\" ]] return config except Exception as load_config_error : warnings . warn ( f ' \\n Config file at \"{location}\" has errors: {load_config_error}' ) return {}","title":"Config"},{"location":"reference/portray/config/#module-portrayconfig","text":"Defines the configuration defaults and load functions used by portray View Source \"\"\"Defines the configuration defaults and load functions used by `portray`\"\"\" import _ast import ast import os import re import warnings from pathlib import Path from typing import Any , Dict , Optional import mkdocs.config as _mkdocs_config # noqa import mkdocs.exceptions as _mkdocs_exceptions # noqa from git import Repo from toml import load as toml_load from portray.exceptions import NoProjectFound PORTRAY_DEFAULTS = { \"docs_dir\" : \"docs\" , \"extra_dirs\" : [ \"art\" , \"images\" , \"media\" ], \"output_dir\" : \"site\" , \"port\" : 8000 , \"host\" : \"127.0.0.1\" , \"append_directory_to_python_path\" : True , \"include_reference_documentation\" : True , \"labels\" : { \"Cli\" : \"CLI\" , \"Api\" : \"API\" , \"Http\" : \"HTTP\" , \"Pypi\" : \"PyPI\" }, \"extra_markdown_extensions\" : [], } MKDOCS_DEFAULTS : Dict [ str , Any ] = { \"site_name\" : os . path . basename ( os . getcwd ()), \"config_file_path\" : os . getcwd (), \"theme\" : { \"name\" : \"material\" , \"palette\" : { \"primary\" : \"green\" , \"accent\" : \"lightgreen\" }, \"custom_dir\" : os . path . join ( os . path . dirname ( __file__ ), \"mkdocs_templates\" ), }, \"markdown_extensions\" : [ \"admonition\" , \"codehilite\" , \"extra\" , \"pymdownx.details\" , \"pymdownx.highlight\" , ], } PDOCS_DEFAULTS : Dict = { \"overwrite\" : True , \"exclude_source\" : False } def project ( directory : str , config_file : str , ** overrides ) -> dict : \"\"\"Returns back the complete configuration - including all sub configuration components defined below that `portray` was able to determine for the project \"\"\" if not ( os . path . isfile ( os . path . join ( directory , config_file )) or os . path . isfile ( os . path . join ( directory , \"setup.py\" )) or \"modules\" in overrides ): raise NoProjectFound ( directory ) project_config : Dict [ str , Any ] = { ** PORTRAY_DEFAULTS , \"directory\" : directory } if os . path . isfile ( os . path . join ( directory , \"setup.py\" )): project_config . update ( setup_py ( os . path . join ( directory , \"setup.py\" ))) project_config . update ( toml ( os . path . join ( directory , config_file ))) project_config . update ( overrides ) project_config . setdefault ( \"modules\" , [ os . path . basename ( os . getcwd ()) . replace ( \"-\" , \"_\" )]) project_config . setdefault ( \"pdocs\" , {}) . setdefault ( \"modules\" , project_config [ \"modules\" ]) mkdocs_config = project_config . get ( \"mkdocs\" , {}) mkdocs_config . setdefault ( \"extra_markdown_extensions\" , project_config . get ( \"extra_markdown_extensions\" , []) ) project_config [ \"mkdocs\" ] = mkdocs ( directory , ** mkdocs_config ) if \"pdoc3\" in project_config : warnings . warn ( \"pdoc3 config usage is deprecated in favor of pdocs. \" \"pdoc3 section will be ignored. \" , DeprecationWarning , ) project_config [ \"pdocs\" ] = pdocs ( directory , ** project_config . get ( \"pdocs\" , {})) return project_config def setup_py ( location : str ) -> dict : \"\"\"Returns back any configuration info we are able to determine from a setup.py file\"\"\" setup_config = {} try : with open ( location ) as setup_py_file : for node in ast . walk ( ast . parse ( setup_py_file . read ())): if ( type ( node ) == _ast . Call and type ( getattr ( node , \"func\" , None )) == _ast . Name and node . func . id == \"setup\" # type: ignore ): for keyword in node . keywords : # type: ignore if keyword . arg == \"packages\" : setup_config [ \"modules\" ] = ast . literal_eval ( keyword . value ) break break except Exception as error : warnings . warn ( f \"Error ( { error } ) occurred trying to parse setup.py file: { location } \" ) return setup_config def toml ( location : str ) -> dict : \"\"\"Returns back the configuration found within the projects [TOML](https://github.com/toml-lang/toml#toml) config (if there is one). Generally this is a `pyproject.toml` file at the root of the project with a `[tool.portray]` section defined. \"\"\" try : location_exists = os . path . exists ( location ) if not location_exists : warnings . warn ( f ' \\n No config file found at location: \" { location } \"' ) return {} except Exception as detection_error : # pragma: no cover warnings . warn ( f ' \\n Unable to check config at \" { location } \" due to error: { detection_error } ' ) try : toml_config = toml_load ( location ) tools = toml_config . get ( \"tool\" , {}) config = tools . get ( \"portray\" , {}) config [ \"file\" ] = location if \"modules\" not in config : if \"poetry\" in tools and \"name\" in tools [ \"poetry\" ]: config [ \"modules\" ] = [ tools [ \"poetry\" ][ \"name\" ]] elif ( \"flit\" in tools and \"metadata\" in tools [ \"flit\" ] and \"module\" in tools [ \"flit\" ][ \"metadata\" ] ): config [ \"modules\" ] = [ tools [ \"flit\" ][ \"metadata\" ][ \"module\" ]] return config except Exception as load_config_error : warnings . warn ( f ' \\n Config file at \" { location } \" has errors: { load_config_error } ' ) return {} def repository ( directory : str , repo_url : Optional [ str ] = None , repo_name : Optional [ str ] = None , edit_uri : Optional [ str ] = None , normalize_repo_url : bool = True , ** kwargs , ) -> Dict [ str , Optional [ str ]]: \"\"\"Returns back any information that can be determined by introspecting the projects git repo (if there is one). \"\"\" try : if repo_url is None : repo_url = Repo ( directory ) . remotes . origin . url if repo_name is None : match = re . search ( r \"(:(//)?)([\\w\\.@\\:/\\-~]+)(\\.git)?(/)?\" , repo_url ) if match : path = match . groups ()[ 2 ] else : path = repo_url repo_name = path . split ( \"/\" )[ - 1 ] if repo_name . endswith ( \".git\" ): repo_name = repo_name [: - len ( \".git\" )] if edit_uri is None : if \"github\" in repo_url or \"gitlab\" in repo_url : edit_uri = \"edit/main/\" elif \"bitbucket\" in repo_url : edit_uri = \"src/default/docs/\" if normalize_repo_url : if repo_url . startswith ( \"git@\" ) and \":\" in repo_url : tld , path = repo_url [ 4 :] . split ( \":\" ) repo_url = f \"https:// { tld } / { path } \" elif repo_url . startswith ( \"https://\" ) and \"@\" in repo_url : repo_url = f \"https:// { repo_url . split ( '@' )[ 1 ] } \" if repo_url and \"github\" in repo_url or \"gitlab\" in repo_url or \"bitbucket\" in repo_url : repo_url = repo_url . replace ( \".git\" , \"\" ) return { key : value for key , value in { \"repo_url\" : repo_url , \"repo_name\" : repo_name , \"edit_uri\" : edit_uri , } . items () if value } except Exception : warnings . warn ( \"Unable to identify `repo_name`, `repo_url`, and `edit_uri` automatically.\" ) return {} def mkdocs ( directory : str , ** overrides ) -> dict : \"\"\"Returns back the configuration that will be used when running mkdocs\"\"\" mkdocs_config : Dict [ str , Any ] = { ** MKDOCS_DEFAULTS , ** repository ( directory , ** overrides ), ** overrides , } theme = mkdocs_config [ \"theme\" ] if theme [ \"name\" ] . lower () == \"material\" : if \"custom_dir\" in theme : theme [ \"custom_dir\" ] = Path ( theme [ \"custom_dir\" ]) . absolute () . as_posix () else : theme [ \"custom_dir\" ] = MKDOCS_DEFAULTS [ \"theme\" ][ \"custom_dir\" ] nav = mkdocs_config . get ( \"nav\" , None ) if nav and hasattr ( nav [ 0 ], \"copy\" ): mkdocs_config [ \"nav\" ] = [ nav_item . copy () for nav_item in nav ] mkdocs_config [ \"markdown_extensions\" ] = mkdocs_config [ \"markdown_extensions\" ] + mkdocs_config . pop ( \"extra_markdown_extensions\" , [] ) return mkdocs_config def pdocs ( directory : str , ** overrides ) -> dict : \"\"\"Returns back the configuration that will be used when running pdocs\"\"\" defaults = { ** PDOCS_DEFAULTS } defaults . update ( overrides ) return defaults","title":"Module portray.config"},{"location":"reference/portray/config/#variables","text":"MKDOCS_DEFAULTS PDOCS_DEFAULTS PORTRAY_DEFAULTS","title":"Variables"},{"location":"reference/portray/config/#functions","text":"","title":"Functions"},{"location":"reference/portray/config/#mkdocs","text":"def mkdocs ( directory : str , ** overrides ) -> dict Returns back the configuration that will be used when running mkdocs View Source def mkdocs ( directory : str , ** overrides ) -> dict : \"\"\"Returns back the configuration that will be used when running mkdocs\"\"\" mkdocs_config : Dict [ str , Any ] = { ** MKDOCS_DEFAULTS , ** repository ( directory , ** overrides ), ** overrides , } theme = mkdocs_config [ \"theme\" ] if theme [ \"name\" ]. lower () == \"material\" : if \"custom_dir\" in theme : theme [ \"custom_dir\" ] = Path ( theme [ \"custom_dir\" ]). absolute (). as_posix () else : theme [ \"custom_dir\" ] = MKDOCS_DEFAULTS [ \"theme\" ][ \"custom_dir\" ] nav = mkdocs_config . get ( \"nav\" , None ) if nav and hasattr ( nav [ 0 ], \"copy\" ) : mkdocs_config [ \"nav\" ] = [ nav_item . copy () for nav_item in nav ] mkdocs_config [ \"markdown_extensions\" ] = mkdocs_config [ \"markdown_extensions\" ] + mkdocs_config . pop ( \"extra_markdown_extensions\" , [] ) return mkdocs_config","title":"mkdocs"},{"location":"reference/portray/config/#pdocs","text":"def pdocs ( directory : str , ** overrides ) -> dict Returns back the configuration that will be used when running pdocs View Source def pdocs ( directory : str , ** overrides ) -> dict : \"\"\"Returns back the configuration that will be used when running pdocs\"\"\" defaults = { ** PDOCS_DEFAULTS } defaults . update ( overrides ) return defaults","title":"pdocs"},{"location":"reference/portray/config/#project","text":"def project ( directory : str , config_file : str , ** overrides ) -> dict Returns back the complete configuration - including all sub configuration components defined below that portray was able to determine for the project View Source def project ( directory : str , config_file : str , ** overrides ) -> dict : \" \"\" Returns back the complete configuration - including all sub configuration components defined below that `portray` was able to determine for the project \"\" \" if not ( os . path . isfile ( os . path . join ( directory , config_file )) or os . path . isfile ( os . path . join ( directory , \"setup.py\" )) or \"modules\" in overrides ) : raise NoProjectFound ( directory ) project_config : Dict [ str , Any ] = { ** PORTRAY_DEFAULTS , \"directory\" : directory } if os . path . isfile ( os . path . join ( directory , \"setup.py\" )) : project_config . update ( set up_py ( os . path . join ( directory , \"setup.py\" ))) project_config . update ( toml ( os . path . join ( directory , config_file ))) project_config . update ( overrides ) project_config . set default ( \"modules\" , [ os . path . basename ( os . getcwd ()). replace ( \"-\" , \"_\" ) ] ) project_config . set default ( \"pdocs\" , {} ). set default ( \"modules\" , project_config [ \"modules\" ] ) mkdocs_config = project_config . get ( \"mkdocs\" , {} ) mkdocs_config . set default ( \"extra_markdown_extensions\" , project_config . get ( \"extra_markdown_extensions\" , [] ) ) project_config [ \"mkdocs\" ] = mkdocs ( directory , ** mkdocs_config ) if \"pdoc3\" in project_config : warnings . warn ( \"pdoc3 config usage is deprecated in favor of pdocs. \" \"pdoc3 section will be ignored. \" , DeprecationWarning , ) project_config [ \"pdocs\" ] = pdocs ( directory , ** project_config . get ( \"pdocs\" , {} )) return project_config","title":"project"},{"location":"reference/portray/config/#repository","text":"def repository ( directory : str , repo_url : Union [ str , NoneType ] = None , repo_name : Union [ str , NoneType ] = None , edit_uri : Union [ str , NoneType ] = None , normalize_repo_url : bool = True , ** kwargs ) -> Dict [ str , Union [ str , NoneType ]] Returns back any information that can be determined by introspecting the projects git repo (if there is one). View Source def repository ( directory : str , repo_url : Optional [ str ] = None , repo_name : Optional [ str ] = None , edit_uri : Optional [ str ] = None , normalize_repo_url : bool = True , ** kwargs , ) -> Dict [ str , Optional [ str ]] : \"\"\"Returns back any information that can be determined by introspecting the projects git repo ( if there is one ). \"\"\" try : if repo_url is None : repo_url = Repo ( directory ). remotes . origin . url if repo_name is None : match = re . search ( r \"(:(//)?)([\\w\\.@\\:/\\-~]+)(\\.git)?(/)?\" , repo_url ) if match : path = match . groups ()[ 2 ] else : path = repo_url repo_name = path . split ( \"/\" )[ -1 ] if repo_name . endswith ( \".git\" ) : repo_name = repo_name [ : - len ( \".git\" )] if edit_uri is None : if \"github\" in repo_url or \"gitlab\" in repo_url : edit_uri = \"edit/main/\" elif \"bitbucket\" in repo_url : edit_uri = \"src/default/docs/\" if normalize_repo_url : if repo_url . startswith ( \"git@\" ) and \":\" in repo_url : tld , path = repo_url [ 4 : ]. split ( \":\" ) repo_url = f \"https://{tld}/{path}\" elif repo_url . startswith ( \"https://\" ) and \"@\" in repo_url : repo_url = f \"https://{repo_url.split('@')[1]}\" if repo_url and \"github\" in repo_url or \"gitlab\" in repo_url or \"bitbucket\" in repo_url : repo_url = repo_url . replace ( \".git\" , \"\" ) return { key : value for key , value in { \"repo_url\" : repo_url , \"repo_name\" : repo_name , \"edit_uri\" : edit_uri , }. items () if value } except Exception : warnings . warn ( \"Unable to identify `repo_name`, `repo_url`, and `edit_uri` automatically.\" ) return {}","title":"repository"},{"location":"reference/portray/config/#setup_py","text":"def setup_py ( location : str ) -> dict Returns back any configuration info we are able to determine from a setup.py file View Source def setup_py ( location : str ) -> dict : \"\"\"Returns back any configuration info we are able to determine from a setup.py file\"\"\" setup_config = {} try : with open ( location ) as setup_py_file : for node in ast . walk ( ast . parse ( setup_py_file . read ())) : if ( type ( node ) == _ast . Call and type ( getattr ( node , \"func\" , None )) == _ast . Name and node . func . id == \"setup\" # type : ignore ) : for keyword in node . keywords : # type : ignore if keyword . arg == \"packages\" : setup_config [ \"modules\" ] = ast . literal_eval ( keyword . value ) break break except Exception as error : warnings . warn ( f \"Error ({error}) occurred trying to parse setup.py file: {location}\" ) return setup_config","title":"setup_py"},{"location":"reference/portray/config/#toml","text":"def toml ( location : str ) -> dict Returns back the configuration found within the projects TOML config (if there is one). Generally this is a pyproject.toml file at the root of the project with a [tool.portray] section defined. View Source def toml ( location : str ) -> dict : \"\"\"Returns back the configuration found within the projects [TOML](https://github.com/toml-lang/toml#toml) config (if there is one). Generally this is a `pyproject.toml` file at the root of the project with a `[tool.portray]` section defined. \"\"\" try : location_exists = os . path . exists ( location ) if not location_exists : warnings . warn ( f ' \\n No config file found at location: \"{location}\"' ) return {} except Exception as detection_error : # pragma: no cover warnings . warn ( f ' \\n Unable to check config at \"{location}\" due to error: {detection_error}' ) try : toml_config = toml_load ( location ) tools = toml_config . get ( \"tool\" , {}) config = tools . get ( \"portray\" , {}) config [ \"file\" ] = location if \"modules\" not in config : if \"poetry\" in tools and \"name\" in tools [ \"poetry\" ]: config [ \"modules\" ] = [ tools [ \"poetry\" ][ \"name\" ]] elif ( \"flit\" in tools and \"metadata\" in tools [ \"flit\" ] and \"module\" in tools [ \"flit\" ][ \"metadata\" ] ): config [ \"modules\" ] = [ tools [ \"flit\" ][ \"metadata\" ][ \"module\" ]] return config except Exception as load_config_error : warnings . warn ( f ' \\n Config file at \"{location}\" has errors: {load_config_error}' ) return {}","title":"toml"},{"location":"reference/portray/exceptions/","text":"Module portray.exceptions All portray specific exception classes should be defined here View Source \"\"\"All portray specific exception classes should be defined here\"\"\" class PortrayError ( Exception ) : \"\"\"Base class for all exceptions returned from portray\"\"\" pass class NoProjectFound ( PortrayError ) : \"\"\"Thrown when portray is ran in a directory with no Python project\"\"\" def __init__ ( self , directory : str ) : super () . __init__ ( self , f \"No Python project found in the given directory: '{directory}'\" + \" See: https://timothycrosley.github.io/portray/TROUBLESHOOTING/#noprojectfound\" , ) self . directory = directory class DocumentationAlreadyExists ( PortrayError ) : \"\"\"Thrown when portray has been told to output documentation where it already exists\"\"\" def __init__ ( self , directory : str ) : super () . __init__ ( self , f \"Documentation already exists in '{directory}'. Use --overwrite to ignore\" ) self . directory = directory Classes DocumentationAlreadyExists class DocumentationAlreadyExists ( directory : str ) Thrown when portray has been told to output documentation where it already exists View Source class DocumentationAlreadyExists ( PortrayError ): \"\"\"Thrown when portray has been told to output documentation where it already exists\"\"\" def __init__ ( self , directory: str ): super (). __init__ ( self , f \"Documentation already exists in '{directory}'. Use --overwrite to ignore\" ) self . directory = directory Ancestors (in MRO) portray.exceptions.PortrayError builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. NoProjectFound class NoProjectFound ( directory : str ) Thrown when portray is ran in a directory with no Python project View Source class NoProjectFound ( PortrayError ): \"\"\"Thrown when portray is ran in a directory with no Python project\"\"\" def __init__ ( self , directory: str ): super (). __init__ ( self , f \"No Python project found in the given directory: '{directory}'\" + \" See: https://timothycrosley.github.io/portray/TROUBLESHOOTING/#noprojectfound\" , ) self . directory = directory Ancestors (in MRO) portray.exceptions.PortrayError builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. PortrayError class PortrayError ( / , * args , ** kwargs ) Base class for all exceptions returned from portray View Source class PortrayError ( Exception ): \"\"\"Base class for all exceptions returned from portray\"\"\" pass Ancestors (in MRO) builtins.Exception builtins.BaseException Descendants portray.exceptions.NoProjectFound portray.exceptions.DocumentationAlreadyExists Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Exceptions"},{"location":"reference/portray/exceptions/#module-portrayexceptions","text":"All portray specific exception classes should be defined here View Source \"\"\"All portray specific exception classes should be defined here\"\"\" class PortrayError ( Exception ) : \"\"\"Base class for all exceptions returned from portray\"\"\" pass class NoProjectFound ( PortrayError ) : \"\"\"Thrown when portray is ran in a directory with no Python project\"\"\" def __init__ ( self , directory : str ) : super () . __init__ ( self , f \"No Python project found in the given directory: '{directory}'\" + \" See: https://timothycrosley.github.io/portray/TROUBLESHOOTING/#noprojectfound\" , ) self . directory = directory class DocumentationAlreadyExists ( PortrayError ) : \"\"\"Thrown when portray has been told to output documentation where it already exists\"\"\" def __init__ ( self , directory : str ) : super () . __init__ ( self , f \"Documentation already exists in '{directory}'. Use --overwrite to ignore\" ) self . directory = directory","title":"Module portray.exceptions"},{"location":"reference/portray/exceptions/#classes","text":"","title":"Classes"},{"location":"reference/portray/exceptions/#documentationalreadyexists","text":"class DocumentationAlreadyExists ( directory : str ) Thrown when portray has been told to output documentation where it already exists View Source class DocumentationAlreadyExists ( PortrayError ): \"\"\"Thrown when portray has been told to output documentation where it already exists\"\"\" def __init__ ( self , directory: str ): super (). __init__ ( self , f \"Documentation already exists in '{directory}'. Use --overwrite to ignore\" ) self . directory = directory","title":"DocumentationAlreadyExists"},{"location":"reference/portray/exceptions/#ancestors-in-mro","text":"portray.exceptions.PortrayError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/portray/exceptions/#class-variables","text":"args","title":"Class variables"},{"location":"reference/portray/exceptions/#methods","text":"","title":"Methods"},{"location":"reference/portray/exceptions/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/portray/exceptions/#noprojectfound","text":"class NoProjectFound ( directory : str ) Thrown when portray is ran in a directory with no Python project View Source class NoProjectFound ( PortrayError ): \"\"\"Thrown when portray is ran in a directory with no Python project\"\"\" def __init__ ( self , directory: str ): super (). __init__ ( self , f \"No Python project found in the given directory: '{directory}'\" + \" See: https://timothycrosley.github.io/portray/TROUBLESHOOTING/#noprojectfound\" , ) self . directory = directory","title":"NoProjectFound"},{"location":"reference/portray/exceptions/#ancestors-in-mro_1","text":"portray.exceptions.PortrayError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/portray/exceptions/#class-variables_1","text":"args","title":"Class variables"},{"location":"reference/portray/exceptions/#methods_1","text":"","title":"Methods"},{"location":"reference/portray/exceptions/#with_traceback_1","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/portray/exceptions/#portrayerror","text":"class PortrayError ( / , * args , ** kwargs ) Base class for all exceptions returned from portray View Source class PortrayError ( Exception ): \"\"\"Base class for all exceptions returned from portray\"\"\" pass","title":"PortrayError"},{"location":"reference/portray/exceptions/#ancestors-in-mro_2","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/portray/exceptions/#descendants","text":"portray.exceptions.NoProjectFound portray.exceptions.DocumentationAlreadyExists","title":"Descendants"},{"location":"reference/portray/exceptions/#class-variables_2","text":"args","title":"Class variables"},{"location":"reference/portray/exceptions/#methods_2","text":"","title":"Methods"},{"location":"reference/portray/exceptions/#with_traceback_2","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/portray/logo/","text":"Module portray.logo __ / \\ \\ __ _____ ___ _ __ \\ \\ , _ \\ _ __ __ __ __ / \\ '__`\\ / __`\\/\\`' __ \\ \\ \\ / / \\ ` '__\\/' __ ` \\ / \\ \\ / \\ \\ \\ \\ \\ L \\ \\ / \\ \\ L \\ \\ \\ \\ / \\ \\ \\ _ \\ \\ \\ // \\ \\ L \\ . \\ _ \\ \\ \\ _ \\ \\ \\ \\ , __ / \\ \\ ____ / \\ \\ _ \\ \\ \\ __ \\\\ \\ _ \\\\ \\ __ /. \\ _ \\\\ / ` ____ \\ \\ \\ \\ / \\ / ___ / \\ / _ / \\ / __ / \\ / _ / \\ / __ / \\ / _ / ` / ___ /> \\ \\ \\ _ \\ / \\ ___ / \\ / _ / \\ / __ / Your Project with Great Documentation . Version : 1.8.0 Copyright Timothy Edmund Crosley 2019 MIT License View Source from portray._version import __version__ ascii_art = rf \"\"\" __ /\\ \\__ _____ ___ _ __\\ \\ ,_\\ _ __ __ __ __ /\\ '__`\\ / __`\\/\\`'__\\ \\ \\/ /\\`'__\\/'__`\\ /\\ \\/\\ \\ \\ \\ \\L\\ \\/\\ \\L\\ \\ \\ \\/ \\ \\ \\_\\ \\ \\//\\ \\L\\.\\_\\ \\ \\_\\ \\ \\ \\ ,__/\\ \\____/\\ \\_\\ \\ \\__\\\\ \\_\\\\ \\__/.\\_\\\\/`____ \\ \\ \\ \\/ \\/___/ \\/_/ \\/__/ \\/_/ \\/__/\\/_/ `/___/> \\ \\ \\_\\ /\\___/ \\/_/ \\/__/ Your Project with Great Documentation. Version: { __version__ } Copyright Timothy Edmund Crosley 2019 MIT License \"\"\" __doc__ = f \"\"\" ```python { ascii_art } ``` \"\"\" Variables ascii_art","title":"Logo"},{"location":"reference/portray/logo/#module-portraylogo","text":"__ / \\ \\ __ _____ ___ _ __ \\ \\ , _ \\ _ __ __ __ __ / \\ '__`\\ / __`\\/\\`' __ \\ \\ \\ / / \\ ` '__\\/' __ ` \\ / \\ \\ / \\ \\ \\ \\ \\ L \\ \\ / \\ \\ L \\ \\ \\ \\ / \\ \\ \\ _ \\ \\ \\ // \\ \\ L \\ . \\ _ \\ \\ \\ _ \\ \\ \\ \\ , __ / \\ \\ ____ / \\ \\ _ \\ \\ \\ __ \\\\ \\ _ \\\\ \\ __ /. \\ _ \\\\ / ` ____ \\ \\ \\ \\ / \\ / ___ / \\ / _ / \\ / __ / \\ / _ / \\ / __ / \\ / _ / ` / ___ /> \\ \\ \\ _ \\ / \\ ___ / \\ / _ / \\ / __ / Your Project with Great Documentation . Version : 1.8.0 Copyright Timothy Edmund Crosley 2019 MIT License View Source from portray._version import __version__ ascii_art = rf \"\"\" __ /\\ \\__ _____ ___ _ __\\ \\ ,_\\ _ __ __ __ __ /\\ '__`\\ / __`\\/\\`'__\\ \\ \\/ /\\`'__\\/'__`\\ /\\ \\/\\ \\ \\ \\ \\L\\ \\/\\ \\L\\ \\ \\ \\/ \\ \\ \\_\\ \\ \\//\\ \\L\\.\\_\\ \\ \\_\\ \\ \\ \\ ,__/\\ \\____/\\ \\_\\ \\ \\__\\\\ \\_\\\\ \\__/.\\_\\\\/`____ \\ \\ \\ \\/ \\/___/ \\/_/ \\/__/ \\/_/ \\/__/\\/_/ `/___/> \\ \\ \\_\\ /\\___/ \\/_/ \\/__/ Your Project with Great Documentation. Version: { __version__ } Copyright Timothy Edmund Crosley 2019 MIT License \"\"\" __doc__ = f \"\"\" ```python { ascii_art } ``` \"\"\"","title":"Module portray.logo"},{"location":"reference/portray/logo/#variables","text":"ascii_art","title":"Variables"},{"location":"reference/portray/render/","text":"Module portray.render Defines how to render the current project and project_config using the included documentation generation utilities. View Source \"\"\"Defines how to render the current project and project_config using the included documentation generation utilities. \"\"\" import os import shutil import sys import tempfile from contextlib import contextmanager from glob import glob from typing import Dict , Iterator , Tuple import mkdocs . config as mkdocs_config import mkdocs . exceptions as _ mkdocs_exceptions from mkdocs . commands . build import build as mkdocs_build from mkdocs . config . defaults import get_schema as mkdocs_schema from mkdocs . utils import is_markdown_file from pdocs import as_markdown as pdocs_as_markdown from yaspin import yaspin from portray . exceptions import DocumentationAlreadyExists NO_HOME_PAGE = \"\"\" # Nothing here `portray` uses README.md as your projects home page. It appears you do not yet have a README.md file created. \"\"\" def documentation ( config : dict , overwrite : bool = False ) -> None : \"\"\"Renders the entire project given the project config into the config's specified output directory. Behind the scenes: - A temporary directory is created and your code is copy and pasted there - pdoc is ran over your code with the output sent into the temporary directory as Markdown documents - MkDocs is ran over all of your projects Markdown documents including those generated py pdoc. MkDocs outputs an HTML representation to a new temporary directory. - The html temporary directory is copied into your specified output location - Both temporary directories are deleted. \"\"\" if os . path . exists ( config [ \"output_dir\" ]) : if overwrite : shutil . rmtree ( config [ \"output_dir\" ]) else : raise DocumentationAlreadyExists ( config [ \"output_dir\" ]) with documentation_in_temp_folder ( config ) as ( _ , documentation_output ) : shutil . copytree ( documentation_output , config [ \"output_dir\" ]) def pdocs ( config : dict ) -> None : \"\"\"Render this project using the specified pdoc config passed into pdoc. This rendering is from code definition to Markdown so that it will be compatible with MkDocs. \"\"\" pdocs_as_markdown ( **config ) def mkdocs ( config : dict ) : \"\"\"Render the project's associated Markdown documentation using the specified MkDocs config passed into the MkDocs `build` command. This rendering is from `.md` Markdown documents into HTML \"\"\" config_instance = _ mkdocs_config ( config ) return mkdocs_build ( config_instance ) @contextmanager def documentation_in_temp_folder ( config : dict ) -> Iterator [ Tuple [ str , str ]] : \"\"\"Build documentation within a temp folder, returning that folder name before it is deleted.\"\"\" if config [ \"append_directory_to_python_path\" ] and not config [ \"directory\" ] in sys . path : sys . path . append ( config [ \"directory\" ]) with tempfile . TemporaryDirectory () as input_dir : input_dir = os . path . join ( input_dir , \"input\" ) os . mkdir ( input_dir ) with tempfile . TemporaryDirectory () as temp_output_dir : with yaspin ( text= \"Copying source documentation to temporary compilation directory\" ) as spinner : for root_file in os . listdir ( config [ \"directory\" ]) : root_file_absolute = os . path . join ( config [ \"directory\" ], root_file ) if os . path . isfile ( root_file_absolute ) and is_markdown_file ( root_file_absolute ) : shutil . copyfile ( root_file_absolute , os . path . join ( input_dir , root_file )) for source_directory in [ config [ \"docs_dir\" ]] + config [ \"extra_dirs\" ] : directory_absolute = os . path . join ( config [ \"directory\" ], source_directory ) if os . path . isdir ( directory_absolute ) : shutil . copytree ( directory_absolute , os . path . join ( input_dir , source_directory ) ) spinner . ok ( \"Done\" ) if \"docs_dir\" not in config [ \"mkdocs\" ] : config [ \"mkdocs\" ][ \"docs_dir\" ] = input_dir if \"site_dir\" not in config [ \"mkdocs\" ] : config [ \"mkdocs\" ][ \"site_dir\" ] = temp_output_dir if \"nav\" not in config [ \"mkdocs\" ] : nav = config [ \"mkdocs\" ][ \"nav\" ] = [] root_docs = sorted ( glob ( os . path . join ( input_dir , \"*.md\" ))) readme_doc = os . path . join ( input_dir , \"README.md\" ) if readme_doc in root_docs : root_docs . remove ( readme_doc ) else : with open ( readme_doc , \"w\" ) as readme_doc_file : readme_doc_file . write ( NO_HOME_PAGE ) nav . append ({ \"Home\" : \"README.md\" }) nav . extend ( _ doc ( doc , input_dir , config ) for doc in root_docs ) nav . extend ( _ nested_docs ( os . path . join ( input_dir , config [ \"docs_dir\" ]), input_dir , config ) ) else : nav = config [ \"mkdocs\" ][ \"nav\" ] if nav : index_nav = nav [ 0 ] index_page : str = \"\" if index_nav and isinstance ( index_nav , dict ) : index_page = tuple ( index_nav . val ues ())[ 0 ] elif isinstance ( index_nav , str ) : # pragma : no cover index_page = index_nav if index_page : destination_index_page = os . path . join ( input_dir , \"index.md\" ) if ( index_page ! = \"README.md\" and index_page ! = \"index.md\" and not os . path . exists ( destination_index_page ) ) : shutil . copyfile ( os . path . join ( input_dir , index_page ), destination_index_page ) if config [ \"include_reference_documentation\" ] : with yaspin ( text= \"Auto generating reference documentation using pdocs\" ) as spinner : if \"output_dir\" not in config [ \"pdocs\" ] : config [ \"pdocs\" ][ \"output_dir\" ] = os . path . join ( input_dir , \"reference\" ) pdocs ( config [ \"pdocs\" ]) reference_docs = _ nested_docs ( config [ \"pdocs\" ][ \"output_dir\" ], input_dir , config ) nav . append ({ \"Reference\" : reference_docs }) # type : ignore spinner . ok ( \"Done\" ) with yaspin ( text= \"Rendering complete website from Markdown using MkDocs\" ) as spinner : mkdocs ( config [ \"mkdocs\" ]) spinner . ok ( \"Done\" ) # remove any settings pointing to the temp dirs if config [ \"mkdocs\" ][ \"docs_dir\" ]. startswith ( input_dir ) : del config [ \"mkdocs\" ][ \"docs_dir\" ] if config [ \"mkdocs\" ][ \"site_dir\" ]. startswith ( temp_output_dir ) : del config [ \"mkdocs\" ][ \"site_dir\" ] if config [ \"pdocs\" ][ \"output_dir\" ]. startswith ( input_dir ) : del config [ \"pdocs\" ][ \"output_dir\" ] if config [ \"include_reference_documentation\" ] : nav . pop () yield input_dir , temp_output_dir def _ mkdocs_config ( config : dict ) -> mkdocs_config . Config : config_instance = mkdocs_config . Config ( schema = mkdocs_schema ()) config_instance . load_dict ( config ) errors , warnings = config_instance . val idate () if errors : print ( errors ) raise _ mkdocs_exceptions . ConfigurationError ( f \"Aborted with {len(errors)} Configuration Errors!\" ) elif config . get ( \"strict\" , False ) and warnings : # pragma : no cover print ( warnings ) raise _ mkdocs_exceptions . ConfigurationError ( f \"Aborted with {len(warnings)} Configuration Warnings in 'strict' mode!\" ) config_instance . config_file_path = config [ \"config_file_path\" ] return config_instance def _ nested_docs ( directory : str , root_directory : str , config : dict ) -> list : nav = [ _ doc ( doc , root_directory , config ) for doc in sorted ( glob ( os . path . join ( directory , \"*.md\" ))) ] nested_dirs = sorted ( glob ( os . path . join ( directory , \"*/\" ))) for nested_dir in nested_dirs : if ( len ( glob ( os . path . join ( nested_dir , \"*.md\" )) + glob ( os . path . join ( nested_dir , \"**/*.md\" ))) > 0 ) : dir_nav = { _ label ( nested_dir [ :- 1 ], config ) : _ nested_docs ( nested_dir , root_directory , config ) } nav . append ( dir_nav ) # type : ignore return nav def _ label ( path : str , config : Dict ) -> str : label = os . path . basename ( path ) if \".\" in label : label = \".\" . join ( label . split ( \".\" )[ :- 1 ]) label = label . replace ( \"-\" , \" \" ). replace ( \"_\" , \" \" ). title () return config [ \"labels\" ]. get ( label , label ) def _ doc ( path : str , root_path : str , config : dict ) -> Dict [ str , str ] : path = os . path . relpath ( path , root_path ) return { _ label ( path , config ) : path } Variables NO_HOME_PAGE Functions documentation def documentation ( config : dict , overwrite : bool = False ) -> None Renders the entire project given the project config into the config's specified output directory. Behind the scenes: A temporary directory is created and your code is copy and pasted there pdoc is ran over your code with the output sent into the temporary directory as Markdown documents MkDocs is ran over all of your projects Markdown documents including those generated py pdoc. MkDocs outputs an HTML representation to a new temporary directory. The html temporary directory is copied into your specified output location Both temporary directories are deleted. View Source def documentation ( config : dict , overwrite : bool = False ) -> None : \"\"\"Renders the entire project given the project config into the config' s specified output directory . Behind the scenes : - A temporary directory is created and your code is copy and pasted there - pdoc is ran over your code with the output sent into the temporary directory as Markdown documents - MkDocs is ran over all of your projects Markdown documents including those generated py pdoc . MkDocs outputs an HTML representation to a new temporary directory . - The html temporary directory is copied into your specified output location - Both temporary directories are deleted . \"\"\" if os.path.exists(config[\" output_dir \"]): if overwrite: shutil.rmtree(config[\" output_dir \"]) else: raise DocumentationAlreadyExists(config[\" output_dir \"]) with documentation_in_temp_folder(config) as (_, documentation_output): shutil.copytree(documentation_output, config[\" output_dir \"]) documentation_in_temp_folder def documentation_in_temp_folder ( config : dict ) -> Iterator [ Tuple [ str , str ]] Build documentation within a temp folder, returning that folder name before it is deleted. View Source @contextmanager def documentation_in_temp_folder ( config : dict ) -> Iterator [ Tuple[str, str ] ]: \"\"\"Build documentation within a temp folder, returning that folder name before it is deleted.\"\"\" if config [ \"append_directory_to_python_path\" ] and not config [ \"directory\" ] in sys . path : sys . path . append ( config [ \"directory\" ] ) with tempfile . TemporaryDirectory () as input_dir : input_dir = os . path . join ( input_dir , \"input\" ) os . mkdir ( input_dir ) with tempfile . TemporaryDirectory () as temp_output_dir : with yaspin ( text = \"Copying source documentation to temporary compilation directory\" ) as spinner : for root_file in os . listdir ( config [ \"directory\" ] ) : root_file_absolute = os . path . join ( config [ \"directory\" ] , root_file ) if os . path . isfile ( root_file_absolute ) and is_markdown_file ( root_file_absolute ) : shutil . copyfile ( root_file_absolute , os . path . join ( input_dir , root_file )) for source_directory in [ config[\"docs_dir\" ] ] + config [ \"extra_dirs\" ] : directory_absolute = os . path . join ( config [ \"directory\" ] , source_directory ) if os . path . isdir ( directory_absolute ) : shutil . copytree ( directory_absolute , os . path . join ( input_dir , source_directory ) ) spinner . ok ( \"Done\" ) if \"docs_dir\" not in config [ \"mkdocs\" ] : config [ \"mkdocs\" ][ \"docs_dir\" ] = input_dir if \"site_dir\" not in config [ \"mkdocs\" ] : config [ \"mkdocs\" ][ \"site_dir\" ] = temp_output_dir if \"nav\" not in config [ \"mkdocs\" ] : nav = config [ \"mkdocs\" ][ \"nav\" ] = [] root_docs = sorted ( glob ( os . path . join ( input_dir , \"*.md\" ))) readme_doc = os . path . join ( input_dir , \"README.md\" ) if readme_doc in root_docs : root_docs . remove ( readme_doc ) else : with open ( readme_doc , \"w\" ) as readme_doc_file : readme_doc_file . write ( NO_HOME_PAGE ) nav . append ( { \"Home\" : \"README.md\" } ) nav . extend ( _doc ( doc , input_dir , config ) for doc in root_docs ) nav . extend ( _nested_docs ( os . path . join ( input_dir , config [ \"docs_dir\" ] ), input_dir , config ) ) else : nav = config [ \"mkdocs\" ][ \"nav\" ] if nav : index_nav = nav [ 0 ] index_page : str = \"\" if index_nav and isinstance ( index_nav , dict ) : index_page = tuple ( index_nav . values ()) [ 0 ] elif isinstance ( index_nav , str ) : # pragma : no cover index_page = index_nav if index_page : destination_index_page = os . path . join ( input_dir , \"index.md\" ) if ( index_page != \"README.md\" and index_page != \"index.md\" and not os . path . exists ( destination_index_page ) ) : shutil . copyfile ( os . path . join ( input_dir , index_page ), destination_index_page ) if config [ \"include_reference_documentation\" ] : with yaspin ( text = \"Auto generating reference documentation using pdocs\" ) as spinner : if \"output_dir\" not in config [ \"pdocs\" ] : config [ \"pdocs\" ][ \"output_dir\" ] = os . path . join ( input_dir , \"reference\" ) pdocs ( config [ \"pdocs\" ] ) reference_docs = _nested_docs ( config [ \"pdocs\" ][ \"output_dir\" ] , input_dir , config ) nav . append ( { \"Reference\" : reference_docs } ) # type : ignore spinner . ok ( \"Done\" ) with yaspin ( text = \"Rendering complete website from Markdown using MkDocs\" ) as spinner : mkdocs ( config [ \"mkdocs\" ] ) spinner . ok ( \"Done\" ) # remove any settings pointing to the temp dirs if config [ \"mkdocs\" ][ \"docs_dir\" ] . startswith ( input_dir ) : del config [ \"mkdocs\" ][ \"docs_dir\" ] if config [ \"mkdocs\" ][ \"site_dir\" ] . startswith ( temp_output_dir ) : del config [ \"mkdocs\" ][ \"site_dir\" ] if config [ \"pdocs\" ][ \"output_dir\" ] . startswith ( input_dir ) : del config [ \"pdocs\" ][ \"output_dir\" ] if config [ \"include_reference_documentation\" ] : nav . pop () yield input_dir , temp_output_dir mkdocs def mkdocs ( config : dict ) Render the project's associated Markdown documentation using the specified MkDocs config passed into the MkDocs build command. This rendering is from .md Markdown documents into HTML View Source def mkdocs ( config : dict ) : \" \"\" Render the project's associated Markdown documentation using the specified MkDocs config passed into the MkDocs `build` command. This rendering is from `.md` Markdown documents into HTML \"\" \" config_instance = _mkdocs_config ( config ) return mkdocs_build ( config_instance ) pdocs def pdocs ( config : dict ) -> None Render this project using the specified pdoc config passed into pdoc. This rendering is from code definition to Markdown so that it will be compatible with MkDocs. View Source def pdocs ( config : dict ) -> None : \"\"\"Render this project using the specified pdoc config passed into pdoc. This rendering is from code definition to Markdown so that it will be compatible with MkDocs. \"\"\" pdocs_as_markdown ( ** config )","title":"Render"},{"location":"reference/portray/render/#module-portrayrender","text":"Defines how to render the current project and project_config using the included documentation generation utilities. View Source \"\"\"Defines how to render the current project and project_config using the included documentation generation utilities. \"\"\" import os import shutil import sys import tempfile from contextlib import contextmanager from glob import glob from typing import Dict , Iterator , Tuple import mkdocs . config as mkdocs_config import mkdocs . exceptions as _ mkdocs_exceptions from mkdocs . commands . build import build as mkdocs_build from mkdocs . config . defaults import get_schema as mkdocs_schema from mkdocs . utils import is_markdown_file from pdocs import as_markdown as pdocs_as_markdown from yaspin import yaspin from portray . exceptions import DocumentationAlreadyExists NO_HOME_PAGE = \"\"\" # Nothing here `portray` uses README.md as your projects home page. It appears you do not yet have a README.md file created. \"\"\" def documentation ( config : dict , overwrite : bool = False ) -> None : \"\"\"Renders the entire project given the project config into the config's specified output directory. Behind the scenes: - A temporary directory is created and your code is copy and pasted there - pdoc is ran over your code with the output sent into the temporary directory as Markdown documents - MkDocs is ran over all of your projects Markdown documents including those generated py pdoc. MkDocs outputs an HTML representation to a new temporary directory. - The html temporary directory is copied into your specified output location - Both temporary directories are deleted. \"\"\" if os . path . exists ( config [ \"output_dir\" ]) : if overwrite : shutil . rmtree ( config [ \"output_dir\" ]) else : raise DocumentationAlreadyExists ( config [ \"output_dir\" ]) with documentation_in_temp_folder ( config ) as ( _ , documentation_output ) : shutil . copytree ( documentation_output , config [ \"output_dir\" ]) def pdocs ( config : dict ) -> None : \"\"\"Render this project using the specified pdoc config passed into pdoc. This rendering is from code definition to Markdown so that it will be compatible with MkDocs. \"\"\" pdocs_as_markdown ( **config ) def mkdocs ( config : dict ) : \"\"\"Render the project's associated Markdown documentation using the specified MkDocs config passed into the MkDocs `build` command. This rendering is from `.md` Markdown documents into HTML \"\"\" config_instance = _ mkdocs_config ( config ) return mkdocs_build ( config_instance ) @contextmanager def documentation_in_temp_folder ( config : dict ) -> Iterator [ Tuple [ str , str ]] : \"\"\"Build documentation within a temp folder, returning that folder name before it is deleted.\"\"\" if config [ \"append_directory_to_python_path\" ] and not config [ \"directory\" ] in sys . path : sys . path . append ( config [ \"directory\" ]) with tempfile . TemporaryDirectory () as input_dir : input_dir = os . path . join ( input_dir , \"input\" ) os . mkdir ( input_dir ) with tempfile . TemporaryDirectory () as temp_output_dir : with yaspin ( text= \"Copying source documentation to temporary compilation directory\" ) as spinner : for root_file in os . listdir ( config [ \"directory\" ]) : root_file_absolute = os . path . join ( config [ \"directory\" ], root_file ) if os . path . isfile ( root_file_absolute ) and is_markdown_file ( root_file_absolute ) : shutil . copyfile ( root_file_absolute , os . path . join ( input_dir , root_file )) for source_directory in [ config [ \"docs_dir\" ]] + config [ \"extra_dirs\" ] : directory_absolute = os . path . join ( config [ \"directory\" ], source_directory ) if os . path . isdir ( directory_absolute ) : shutil . copytree ( directory_absolute , os . path . join ( input_dir , source_directory ) ) spinner . ok ( \"Done\" ) if \"docs_dir\" not in config [ \"mkdocs\" ] : config [ \"mkdocs\" ][ \"docs_dir\" ] = input_dir if \"site_dir\" not in config [ \"mkdocs\" ] : config [ \"mkdocs\" ][ \"site_dir\" ] = temp_output_dir if \"nav\" not in config [ \"mkdocs\" ] : nav = config [ \"mkdocs\" ][ \"nav\" ] = [] root_docs = sorted ( glob ( os . path . join ( input_dir , \"*.md\" ))) readme_doc = os . path . join ( input_dir , \"README.md\" ) if readme_doc in root_docs : root_docs . remove ( readme_doc ) else : with open ( readme_doc , \"w\" ) as readme_doc_file : readme_doc_file . write ( NO_HOME_PAGE ) nav . append ({ \"Home\" : \"README.md\" }) nav . extend ( _ doc ( doc , input_dir , config ) for doc in root_docs ) nav . extend ( _ nested_docs ( os . path . join ( input_dir , config [ \"docs_dir\" ]), input_dir , config ) ) else : nav = config [ \"mkdocs\" ][ \"nav\" ] if nav : index_nav = nav [ 0 ] index_page : str = \"\" if index_nav and isinstance ( index_nav , dict ) : index_page = tuple ( index_nav . val ues ())[ 0 ] elif isinstance ( index_nav , str ) : # pragma : no cover index_page = index_nav if index_page : destination_index_page = os . path . join ( input_dir , \"index.md\" ) if ( index_page ! = \"README.md\" and index_page ! = \"index.md\" and not os . path . exists ( destination_index_page ) ) : shutil . copyfile ( os . path . join ( input_dir , index_page ), destination_index_page ) if config [ \"include_reference_documentation\" ] : with yaspin ( text= \"Auto generating reference documentation using pdocs\" ) as spinner : if \"output_dir\" not in config [ \"pdocs\" ] : config [ \"pdocs\" ][ \"output_dir\" ] = os . path . join ( input_dir , \"reference\" ) pdocs ( config [ \"pdocs\" ]) reference_docs = _ nested_docs ( config [ \"pdocs\" ][ \"output_dir\" ], input_dir , config ) nav . append ({ \"Reference\" : reference_docs }) # type : ignore spinner . ok ( \"Done\" ) with yaspin ( text= \"Rendering complete website from Markdown using MkDocs\" ) as spinner : mkdocs ( config [ \"mkdocs\" ]) spinner . ok ( \"Done\" ) # remove any settings pointing to the temp dirs if config [ \"mkdocs\" ][ \"docs_dir\" ]. startswith ( input_dir ) : del config [ \"mkdocs\" ][ \"docs_dir\" ] if config [ \"mkdocs\" ][ \"site_dir\" ]. startswith ( temp_output_dir ) : del config [ \"mkdocs\" ][ \"site_dir\" ] if config [ \"pdocs\" ][ \"output_dir\" ]. startswith ( input_dir ) : del config [ \"pdocs\" ][ \"output_dir\" ] if config [ \"include_reference_documentation\" ] : nav . pop () yield input_dir , temp_output_dir def _ mkdocs_config ( config : dict ) -> mkdocs_config . Config : config_instance = mkdocs_config . Config ( schema = mkdocs_schema ()) config_instance . load_dict ( config ) errors , warnings = config_instance . val idate () if errors : print ( errors ) raise _ mkdocs_exceptions . ConfigurationError ( f \"Aborted with {len(errors)} Configuration Errors!\" ) elif config . get ( \"strict\" , False ) and warnings : # pragma : no cover print ( warnings ) raise _ mkdocs_exceptions . ConfigurationError ( f \"Aborted with {len(warnings)} Configuration Warnings in 'strict' mode!\" ) config_instance . config_file_path = config [ \"config_file_path\" ] return config_instance def _ nested_docs ( directory : str , root_directory : str , config : dict ) -> list : nav = [ _ doc ( doc , root_directory , config ) for doc in sorted ( glob ( os . path . join ( directory , \"*.md\" ))) ] nested_dirs = sorted ( glob ( os . path . join ( directory , \"*/\" ))) for nested_dir in nested_dirs : if ( len ( glob ( os . path . join ( nested_dir , \"*.md\" )) + glob ( os . path . join ( nested_dir , \"**/*.md\" ))) > 0 ) : dir_nav = { _ label ( nested_dir [ :- 1 ], config ) : _ nested_docs ( nested_dir , root_directory , config ) } nav . append ( dir_nav ) # type : ignore return nav def _ label ( path : str , config : Dict ) -> str : label = os . path . basename ( path ) if \".\" in label : label = \".\" . join ( label . split ( \".\" )[ :- 1 ]) label = label . replace ( \"-\" , \" \" ). replace ( \"_\" , \" \" ). title () return config [ \"labels\" ]. get ( label , label ) def _ doc ( path : str , root_path : str , config : dict ) -> Dict [ str , str ] : path = os . path . relpath ( path , root_path ) return { _ label ( path , config ) : path }","title":"Module portray.render"},{"location":"reference/portray/render/#variables","text":"NO_HOME_PAGE","title":"Variables"},{"location":"reference/portray/render/#functions","text":"","title":"Functions"},{"location":"reference/portray/render/#documentation","text":"def documentation ( config : dict , overwrite : bool = False ) -> None Renders the entire project given the project config into the config's specified output directory. Behind the scenes: A temporary directory is created and your code is copy and pasted there pdoc is ran over your code with the output sent into the temporary directory as Markdown documents MkDocs is ran over all of your projects Markdown documents including those generated py pdoc. MkDocs outputs an HTML representation to a new temporary directory. The html temporary directory is copied into your specified output location Both temporary directories are deleted. View Source def documentation ( config : dict , overwrite : bool = False ) -> None : \"\"\"Renders the entire project given the project config into the config' s specified output directory . Behind the scenes : - A temporary directory is created and your code is copy and pasted there - pdoc is ran over your code with the output sent into the temporary directory as Markdown documents - MkDocs is ran over all of your projects Markdown documents including those generated py pdoc . MkDocs outputs an HTML representation to a new temporary directory . - The html temporary directory is copied into your specified output location - Both temporary directories are deleted . \"\"\" if os.path.exists(config[\" output_dir \"]): if overwrite: shutil.rmtree(config[\" output_dir \"]) else: raise DocumentationAlreadyExists(config[\" output_dir \"]) with documentation_in_temp_folder(config) as (_, documentation_output): shutil.copytree(documentation_output, config[\" output_dir \"])","title":"documentation"},{"location":"reference/portray/render/#documentation_in_temp_folder","text":"def documentation_in_temp_folder ( config : dict ) -> Iterator [ Tuple [ str , str ]] Build documentation within a temp folder, returning that folder name before it is deleted. View Source @contextmanager def documentation_in_temp_folder ( config : dict ) -> Iterator [ Tuple[str, str ] ]: \"\"\"Build documentation within a temp folder, returning that folder name before it is deleted.\"\"\" if config [ \"append_directory_to_python_path\" ] and not config [ \"directory\" ] in sys . path : sys . path . append ( config [ \"directory\" ] ) with tempfile . TemporaryDirectory () as input_dir : input_dir = os . path . join ( input_dir , \"input\" ) os . mkdir ( input_dir ) with tempfile . TemporaryDirectory () as temp_output_dir : with yaspin ( text = \"Copying source documentation to temporary compilation directory\" ) as spinner : for root_file in os . listdir ( config [ \"directory\" ] ) : root_file_absolute = os . path . join ( config [ \"directory\" ] , root_file ) if os . path . isfile ( root_file_absolute ) and is_markdown_file ( root_file_absolute ) : shutil . copyfile ( root_file_absolute , os . path . join ( input_dir , root_file )) for source_directory in [ config[\"docs_dir\" ] ] + config [ \"extra_dirs\" ] : directory_absolute = os . path . join ( config [ \"directory\" ] , source_directory ) if os . path . isdir ( directory_absolute ) : shutil . copytree ( directory_absolute , os . path . join ( input_dir , source_directory ) ) spinner . ok ( \"Done\" ) if \"docs_dir\" not in config [ \"mkdocs\" ] : config [ \"mkdocs\" ][ \"docs_dir\" ] = input_dir if \"site_dir\" not in config [ \"mkdocs\" ] : config [ \"mkdocs\" ][ \"site_dir\" ] = temp_output_dir if \"nav\" not in config [ \"mkdocs\" ] : nav = config [ \"mkdocs\" ][ \"nav\" ] = [] root_docs = sorted ( glob ( os . path . join ( input_dir , \"*.md\" ))) readme_doc = os . path . join ( input_dir , \"README.md\" ) if readme_doc in root_docs : root_docs . remove ( readme_doc ) else : with open ( readme_doc , \"w\" ) as readme_doc_file : readme_doc_file . write ( NO_HOME_PAGE ) nav . append ( { \"Home\" : \"README.md\" } ) nav . extend ( _doc ( doc , input_dir , config ) for doc in root_docs ) nav . extend ( _nested_docs ( os . path . join ( input_dir , config [ \"docs_dir\" ] ), input_dir , config ) ) else : nav = config [ \"mkdocs\" ][ \"nav\" ] if nav : index_nav = nav [ 0 ] index_page : str = \"\" if index_nav and isinstance ( index_nav , dict ) : index_page = tuple ( index_nav . values ()) [ 0 ] elif isinstance ( index_nav , str ) : # pragma : no cover index_page = index_nav if index_page : destination_index_page = os . path . join ( input_dir , \"index.md\" ) if ( index_page != \"README.md\" and index_page != \"index.md\" and not os . path . exists ( destination_index_page ) ) : shutil . copyfile ( os . path . join ( input_dir , index_page ), destination_index_page ) if config [ \"include_reference_documentation\" ] : with yaspin ( text = \"Auto generating reference documentation using pdocs\" ) as spinner : if \"output_dir\" not in config [ \"pdocs\" ] : config [ \"pdocs\" ][ \"output_dir\" ] = os . path . join ( input_dir , \"reference\" ) pdocs ( config [ \"pdocs\" ] ) reference_docs = _nested_docs ( config [ \"pdocs\" ][ \"output_dir\" ] , input_dir , config ) nav . append ( { \"Reference\" : reference_docs } ) # type : ignore spinner . ok ( \"Done\" ) with yaspin ( text = \"Rendering complete website from Markdown using MkDocs\" ) as spinner : mkdocs ( config [ \"mkdocs\" ] ) spinner . ok ( \"Done\" ) # remove any settings pointing to the temp dirs if config [ \"mkdocs\" ][ \"docs_dir\" ] . startswith ( input_dir ) : del config [ \"mkdocs\" ][ \"docs_dir\" ] if config [ \"mkdocs\" ][ \"site_dir\" ] . startswith ( temp_output_dir ) : del config [ \"mkdocs\" ][ \"site_dir\" ] if config [ \"pdocs\" ][ \"output_dir\" ] . startswith ( input_dir ) : del config [ \"pdocs\" ][ \"output_dir\" ] if config [ \"include_reference_documentation\" ] : nav . pop () yield input_dir , temp_output_dir","title":"documentation_in_temp_folder"},{"location":"reference/portray/render/#mkdocs","text":"def mkdocs ( config : dict ) Render the project's associated Markdown documentation using the specified MkDocs config passed into the MkDocs build command. This rendering is from .md Markdown documents into HTML View Source def mkdocs ( config : dict ) : \" \"\" Render the project's associated Markdown documentation using the specified MkDocs config passed into the MkDocs `build` command. This rendering is from `.md` Markdown documents into HTML \"\" \" config_instance = _mkdocs_config ( config ) return mkdocs_build ( config_instance )","title":"mkdocs"},{"location":"reference/portray/render/#pdocs","text":"def pdocs ( config : dict ) -> None Render this project using the specified pdoc config passed into pdoc. This rendering is from code definition to Markdown so that it will be compatible with MkDocs. View Source def pdocs ( config : dict ) -> None : \"\"\"Render this project using the specified pdoc config passed into pdoc. This rendering is from code definition to Markdown so that it will be compatible with MkDocs. \"\"\" pdocs_as_markdown ( ** config )","title":"pdocs"}]}